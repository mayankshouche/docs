{
    "openapi": "3.0.3",
    "info": {
      "title": "Mayank API",
      "description": "Mayank OpenAPI Specification. This document describes all of the operations available through the Mayank API.",
      "contact": {
        "name": "Mayank Team",
        "url": "https://Mayank.ai",
        "email": "developers@Mayank.ai"
      },
      "license": {
        "name": "BSL",
        "url": "https://github.com/mayank/Mayank/blob/main/LICENSE.txt"
      },
      "version": "0.11.0"
    },
    "servers": [
      {
        "url": "https://api.Mayank.ai",
        "description": "Production server"
      },
      {
        "url": "http://localhost:8090",
        "description": "Local development server"
      }
    ],
    "paths": {
      "/plants": {
        "post": {
          "tags": [
            "Analytics"
          ],
          "summary": "Get RAG Analytics",
          "description": "This route allows you to view the RAG analytics for a dataset.",
          "operationId": "get_rag_analytics",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to filter the graph",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RAGAnalytics"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "The RAG analytics for the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/RAGAnalyticsResponse"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting RAG analytics",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/analytics/recommendation": {
        "post": {
          "tags": [
            "Analytics"
          ],
          "summary": "Get Recommendation Analytics",
          "description": "This route allows you to view the recommendation analytics for a dataset.",
          "operationId": "get_recommendation_analytics",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to filter the graph",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecommendationAnalytics"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "The recommendation analytics for the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/RecommendationAnalyticsResponse"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting recommendation analytics",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/analytics/search": {
        "post": {
          "tags": [
            "Analytics"
          ],
          "summary": "Get Search Analytics",
          "description": "This route allows you to view the search analytics for a dataset.",
          "operationId": "get_search_analytics",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to filter the graph",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchAnalytics"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "The search analytics for the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/SearchAnalyticsResponse"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting search analytics",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/analytics/search/cluster": {
        "post": {
          "tags": [
            "Analytics"
          ],
          "summary": "Get Cluster Analytics",
          "description": "This route allows you to view the cluster analytics for a dataset.",
          "operationId": "get_cluster_analytics",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to filter the graph",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterAnalytics"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "The cluster analytics for the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ClusterAnalyticsResponse"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting cluster analytics",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/auth": {
        "get": {
          "tags": [
            "Auth"
          ],
          "summary": "Login",
          "description": "This will redirect you to the OAuth provider for authentication with email/pass, SSO, Google, Github, etc.",
          "operationId": "login",
          "parameters": [
            {
              "name": "organization_id",
              "in": "query",
              "description": "ID of organization to authenticate into",
              "required": false,
              "schema": {
                "type": "string",
                "format": "uuid",
                "nullable": true
              }
            },
            {
              "name": "redirect_uri",
              "in": "query",
              "description": "URL to redirect to after successful login",
              "required": false,
              "schema": {
                "type": "string",
                "nullable": true
              }
            },
            {
              "name": "inv_code",
              "in": "query",
              "description": "Code sent via email as a result of successful call to send_invitation",
              "required": false,
              "schema": {
                "type": "string",
                "format": "uuid",
                "nullable": true
              }
            }
          ],
          "responses": {
            "303": {
              "description": "Response that redirects to OAuth provider through a Location header to be handled by browser."
            },
            "400": {
              "description": "OAuth error likely with OIDC provider.",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          }
        },
        "delete": {
          "tags": [
            "Auth"
          ],
          "summary": "Logout",
          "description": "Invalidate your current auth credential stored typically stored in a cookie. This does not invalidate your API key.",
          "operationId": "logout",
          "responses": {
            "204": {
              "description": "Confirmation that your current auth token has been invalidated. This does not invalidate your API key."
            }
          }
        }
      },
      "/api/auth/callback": {
        "get": {
          "tags": [
            "Auth"
          ],
          "summary": "OpenID Connect callback",
          "description": "This is the callback route for the OAuth provider, it should not be called directly. Redirects to browser with set-cookie header.",
          "operationId": "callback",
          "responses": {
            "200": {
              "description": "Response that returns with set-cookie header",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/SlimUser"
                  }
                }
              }
            },
            "400": {
              "description": "Email or password empty or incorrect",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          }
        }
      },
      "/api/auth/me": {
        "get": {
          "tags": [
            "Auth"
          ],
          "summary": "Get Me",
          "description": "Get the user corresponding to your current auth credentials.",
          "operationId": "get_me",
          "responses": {
            "200": {
              "description": "The user corresponding to your current auth credentials",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/SlimUser"
                  }
                }
              }
            },
            "400": {
              "description": "Error message indicitating you are not currently signed in",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunk": {
        "post": {
          "tags": [
            "Chunk"
          ],
          "summary": "Create or Upsert Chunk or Chunks",
          "description": "Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.\nIf uploading in bulk, the maximum amount of chunks that can be uploaded at once is 120 chunks. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "create_chunk",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to create a new chunk (chunk)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateChunkReqPayloadEnum"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "JSON response payload containing the created chunk",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ReturnQueuedChunk"
                  }
                }
              }
            },
            "400": {
              "description": "Error typically due to deserialization issues",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "426": {
              "description": "Error when upgrade is needed to process more chunks",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        },
        "put": {
          "tags": [
            "Chunk"
          ],
          "summary": "Update Chunk",
          "description": "Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "update_chunk",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to update a chunk (chunk)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateChunkReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "204": {
              "description": "No content Ok response indicating the chunk was updated as requested"
            },
            "400": {
              "description": "Service error relating to to updating chunk, likely due to conflicting tracking_id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/chunk/autocomplete": {
        "post": {
          "tags": [
            "Chunk"
          ],
          "summary": "Autocomplete",
          "description": "This route provides the primary autocomplete functionality for the API. This prioritize prefix matching with semantic or full-text search.",
          "operationId": "autocomplete",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "X-API-Version",
              "in": "header",
              "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
              "required": false,
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/APIVersion"
                  }
                ],
                "nullable": true
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to semantically search for chunks (chunks)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AutocompleteReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Chunks with embedding vectors which are similar to those in the request body",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/SearchResponseTypes"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to searching",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunk/count": {
        "post": {
          "tags": [
            "Chunk"
          ],
          "summary": "Count chunks above threshold",
          "description": "This route can be used to determine the number of chunks that match a given search criteria including filters and score threshold. It may be high latency for large datasets. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization. There is a dataset configuration imposed restriction on the maximum limit value (default 10,000) which is used to prevent DDOS attacks.",
          "operationId": "count_chunks",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CountChunksReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Number of chunks satisfying the query",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/CountChunkQueryResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Failed to count chunks",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunk/gen_suggestions": {
        "post": {
          "tags": [
            "Chunk"
          ],
          "summary": "Generate suggested queries",
          "description": "This endpoint will generate 3 suggested queries based off a hybrid search using RAG with the query provided in the request body and return them as a JSON object.",
          "operationId": "get_suggested_queries",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to get alternative suggested queries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuggestedQueriesReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "A JSON object containing a list of alternative suggested queries",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/SuggestedQueriesResponse"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to to updating chunk, likely due to conflicting tracking_id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunk/generate": {
        "post": {
          "tags": [
            "Chunk"
          ],
          "summary": "RAG on Specified Chunks",
          "description": "This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \"search before generate\" page at docs.Mayank.ai.",
          "operationId": "generate_off_chunks",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to perform RAG on some chunks (chunks)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateChunksRequest"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "This will be a JSON response of a string containing the LLM's generated inference. Response if not streaming.",
              "content": {
                "text/plain": {
                  "schema": {
                    "type": "string"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to to updating chunk, likely due to conflicting tracking_id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunk/recommend": {
        "post": {
          "tags": [
            "Chunk"
          ],
          "summary": "Get Recommended Chunks",
          "description": "Get recommendations of chunks similar to the positive samples in the request and dissimilar to the negative. You must provide at least one of either positive_chunk_ids or positive_tracking_ids.",
          "operationId": "get_recommended_chunks",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "X-API-Version",
              "in": "header",
              "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
              "required": false,
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/APIVersion"
                  }
                ],
                "nullable": true
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to get recommendations of chunks similar to the chunks in the request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecommendChunksRequest"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Chunks with embedding vectors which are similar to positives and dissimilar to negatives",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/RecommendResponseTypes"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to to getting similar chunks",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunk/search": {
        "post": {
          "tags": [
            "Chunk"
          ],
          "summary": "Search",
          "description": "This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results' `chunk_html` values will be modified with `\u003Cb\u003E\u003Cmark\u003E` tags for sub-sentence highlighting.",
          "operationId": "search_chunks",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "X-API-Version",
              "in": "header",
              "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
              "required": false,
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/APIVersion"
                  }
                ],
                "nullable": true
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to semantically search for chunks (chunks)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchChunksReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Chunks with embedding vectors which are similar to those in the request body",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/SearchResponseTypes"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to searching",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunk/tracking_id/update": {
        "put": {
          "tags": [
            "Chunk"
          ],
          "summary": "Update Chunk By Tracking Id",
          "description": "Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "update_chunk_by_tracking_id",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to update a chunk by tracking_id (chunks)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateChunkByTrackingIdData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "204": {
              "description": "Confirmation that the chunk has been updated as per your request"
            },
            "400": {
              "description": "Service error relating to to updating chunk",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "deprecated": true,
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/chunk/tracking_id/{tracking_id}": {
        "get": {
          "tags": [
            "Chunk"
          ],
          "summary": "Get Chunk By Tracking Id",
          "description": "Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.",
          "operationId": "get_chunk_by_tracking_id",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "X-API-Version",
              "in": "header",
              "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
              "required": false,
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/APIVersion"
                  }
                ],
                "nullable": true
              }
            },
            {
              "name": "tracking_id",
              "in": "path",
              "description": "tracking_id of the chunk you want to fetch",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "chunk with the tracking_id that you were searching for",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ChunkReturnTypes"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to fidning a chunk by tracking_id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Chunk not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        },
        "delete": {
          "tags": [
            "Chunk"
          ],
          "summary": "Delete Chunk By Tracking Id",
          "description": "Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "delete_chunk_by_tracking_id",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "tracking_id",
              "in": "path",
              "description": "tracking_id of the chunk you want to delete",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "responses": {
            "204": {
              "description": "Confirmation that the chunk with the tracking_id specified was deleted"
            },
            "400": {
              "description": "Service error relating to finding a chunk by tracking_id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/chunk/{chunk_id}": {
        "get": {
          "tags": [
            "Chunk"
          ],
          "summary": "Get Chunk By Id",
          "description": "Get a singular chunk by id.",
          "operationId": "get_chunk_by_id",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "X-API-Version",
              "in": "header",
              "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
              "required": false,
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/APIVersion"
                  }
                ],
                "nullable": true
              }
            },
            {
              "name": "chunk_id",
              "in": "path",
              "description": "Id of the chunk you want to fetch.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "chunk with the id that you were searching for",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ChunkReturnTypes"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to fidning a chunk by tracking_id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Chunk not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        },
        "delete": {
          "tags": [
            "Chunk"
          ],
          "summary": "Delete Chunk",
          "description": "Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "delete_chunk",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "chunk_id",
              "in": "path",
              "description": "Id of the chunk you want to fetch.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "204": {
              "description": "Confirmation that the chunk with the id specified was deleted"
            },
            "400": {
              "description": "Service error relating to finding a chunk by tracking_id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/chunk_group": {
        "post": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Create Chunk Group",
          "description": "Create a new chunk_group. This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "create_chunk_group",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to cretea a chunkGroup",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateChunkGroupReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Returns the created chunkGroup",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ChunkGroup"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to creating the chunkGroup",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        },
        "put": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Update Group",
          "description": "Update a chunk_group. If you try to change the tracking_id to one that already exists, this operation will fail. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "update_chunk_group",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to update a chunkGroup",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateChunkGroupData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "204": {
              "description": "Confirmation that the chunkGroup was updated"
            },
            "400": {
              "description": "Service error relating to updating the chunkGroup",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/chunk_group/chunk/{group_id}": {
        "post": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Add Chunk to Group",
          "description": "Route to add a chunk to a group. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "add_chunk_to_group",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "group_id",
              "in": "path",
              "description": "Id of the group to add the chunk to as a bookmark",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to add a chunk to a group (bookmark it)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddChunkToGroupData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "204": {
              "description": "Confirmation that the chunk was added to the group (bookmark'ed)."
            },
            "400": {
              "description": "Service error relating to getting the groups that the chunk is in.",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        },
        "delete": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Remove Chunk from Group",
          "description": "Route to remove a chunk from a group. Auth'ed user or api key must be an admin or owner of the dataset's organization to remove a chunk from a group.",
          "operationId": "remove_chunk_from_group",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "group_id",
              "in": "path",
              "description": "Id of the group you want to remove the chunk from.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to remove a chunk from a group",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RemoveChunkFromGroupReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "204": {
              "description": "Confirmation that the chunk was removed to the group"
            },
            "400": {
              "description": "Service error relating to removing the chunk from the group",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/chunk_group/chunks": {
        "post": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Get Groups for Chunks",
          "description": "Route to get the groups that a chunk is in.",
          "operationId": "get_groups_chunk_is_in",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to get the groups that a chunk is in",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetGroupsForChunksData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "JSON body representing the groups that the chunk is in",
              "content": {
                "application/json": {
                  "schema": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/BookmarkGroupResponse"
                    }
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting the groups that the chunk is in",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunk_group/group_oriented_search": {
        "post": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Search Over Groups",
          "description": "This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the results will be re-ranked using scores from a cross encoder model. Compatible with semantic, fulltext, or hybrid search modes.",
          "operationId": "search_over_groups",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "X-API-Version",
              "in": "header",
              "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
              "required": false,
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/APIVersion"
                  }
                ],
                "nullable": true
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to semantically search over groups",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchOverGroupsData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Group chunks which are similar to the embedding vector of the search query",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/SearchOverGroupsResponseTypes"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to searching over groups",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunk_group/recommend": {
        "post": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Get Recommended Groups",
          "description": "Route to get recommended groups. This route will return groups which are similar to the groups in the request body. You must provide at least one positive group id or group tracking id.",
          "operationId": "get_recommended_groups",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "X-API-Version",
              "in": "header",
              "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
              "required": false,
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/APIVersion"
                  }
                ],
                "nullable": true
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to get recommendations of chunks similar to the chunks in the request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecommendGroupChunksRequest"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "JSON body representing the groups which are similar to the positive groups and dissimilar to the negative ones",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/RecommendGroupsResponse"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to to getting similar chunks",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunk_group/search": {
        "post": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Search Within Group",
          "description": "This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using scores from a cross encoder model.",
          "operationId": "search_within_group",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "X-API-Version",
              "in": "header",
              "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
              "required": false,
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/APIVersion"
                  }
                ],
                "nullable": true
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to semantically search a group",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SearchWithinGroupData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Group chunks which are similar to the embedding vector of the search query",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/SearchGroupResponseTypes"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting the groups that the chunk is in",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunk_group/tracking_id/{group_tracking_id}/{page}": {
        "get": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Get Chunks in Group by Tracking ID",
          "description": "Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.",
          "operationId": "get_chunks_in_group_by_tracking_id",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "group_tracking_id",
              "in": "path",
              "description": "The id of the group to get the chunks from",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "X-API-Version",
              "in": "header",
              "description": "The version of the API to use for the request",
              "required": false,
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/APIVersion"
                  }
                ],
                "nullable": true
              }
            },
            {
              "name": "page",
              "in": "path",
              "description": "The page of chunks to get from the group",
              "required": true,
              "schema": {
                "type": "integer",
                "format": "int64",
                "minimum": 0
              }
            }
          ],
          "responses": {
            "200": {
              "description": "Chunks present within the specified group",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/BookmarkGroupResponse"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting the groups that the chunk is in",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Group not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunk_group/tracking_id/{tracking_id}": {
        "get": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Get Group by Tracking ID",
          "description": "Fetch the group with the given tracking id.\nget_group_by_tracking_id",
          "operationId": "get_group_by_tracking_id",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "tracking_id",
              "in": "path",
              "description": "The tracking id of the group to fetch.",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "JSON body representing the group with the given tracking id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ChunkGroupAndFileId"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting the group with the given tracking id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Group not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        },
        "post": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Add Chunk to Group by Tracking ID",
          "description": "Route to add a chunk to a group by tracking id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "add_chunk_to_group_by_tracking_id",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "tracking_id",
              "in": "path",
              "description": "Id of the group to add the chunk to as a bookmark",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to add a chunk to a group (bookmark it)",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AddChunkToGroupData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "204": {
              "description": "Confirmation that the chunk was added to the group (bookmark'ed)."
            },
            "400": {
              "description": "Service error relating to getting the groups that the chunk is in.",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "deprecated": true,
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        },
        "put": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Update Group by Tracking ID",
          "description": "Update a chunk_group with the given tracking id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "update_group_by_tracking_id",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "tracking_id",
              "in": "path",
              "description": "Tracking id of the chunk_group to update",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to update a chunkGroup",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateGroupByTrackingIDReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "204": {
              "description": "Confirmation that the chunkGroup was updated"
            },
            "400": {
              "description": "Service error relating to updating the chunkGroup",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "deprecated": true,
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        },
        "delete": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Delete Group by Tracking ID",
          "description": "Delete a chunk_group with the given tracking id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "delete_group_by_tracking_id",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "tracking_id",
              "in": "path",
              "description": "Tracking id of the chunk_group to delete",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "delete_chunks",
              "in": "query",
              "description": "Delete the chunks within the group",
              "required": true,
              "schema": {
                "type": "boolean"
              }
            }
          ],
          "responses": {
            "204": {
              "description": "Confirmation that the chunkGroup was deleted"
            },
            "400": {
              "description": "Service error relating to deleting the chunkGroup",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/chunk_group/{group_id}": {
        "get": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Get Group",
          "description": "Fetch the group with the given id.\nget_group",
          "operationId": "get_chunk_group",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "group_id",
              "in": "path",
              "description": "Id of the group you want to fetch.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "JSON body representing the group with the given tracking id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ChunkGroupAndFileId"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting the group with the given tracking id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Group not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        },
        "delete": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Delete Group",
          "description": "This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "delete_chunk_group",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "group_id",
              "in": "path",
              "description": "Id of the group you want to fetch.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "delete_chunks",
              "in": "query",
              "description": "Delete the chunks within the group",
              "required": true,
              "schema": {
                "type": "boolean"
              }
            }
          ],
          "responses": {
            "204": {
              "description": "Confirmation that the chunkGroup was deleted"
            },
            "400": {
              "description": "Service error relating to deleting the chunkGroup",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/chunk_group/{group_id}/{page}": {
        "get": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Get Chunks in Group",
          "description": "Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.",
          "operationId": "get_chunks_in_group",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "group_id",
              "in": "path",
              "description": "Id of the group you want to fetch.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "X-API-Version",
              "in": "header",
              "description": "The version of the API to use for the request",
              "required": false,
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/APIVersion"
                  }
                ],
                "nullable": true
              }
            },
            {
              "name": "page",
              "in": "path",
              "description": "The page of chunks to get from the group",
              "required": true,
              "schema": {
                "type": "integer",
                "format": "int64",
                "nullable": true,
                "minimum": 0
              }
            }
          ],
          "responses": {
            "200": {
              "description": "Chunks present within the specified group",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/BookmarkGroupResponse"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting the groups that the chunk is in",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Group not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunks": {
        "post": {
          "tags": [
            "Chunk"
          ],
          "summary": "Get Chunks By Ids",
          "description": "Get multiple chunks by multiple ids.",
          "operationId": "get_chunks_by_ids",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "X-API-Version",
              "in": "header",
              "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
              "required": false,
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/APIVersion"
                  }
                ],
                "nullable": true
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to get the chunks in the request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetChunksData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "chunks with the id that you were searching for",
              "content": {
                "application/json": {
                  "schema": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ChunkReturnTypes"
                    }
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to fidning a chunk by tracking_id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Any one of the specified chunks not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/chunks/tracking": {
        "post": {
          "tags": [
            "Chunk"
          ],
          "summary": "Get Chunks By Tracking Ids",
          "description": "Get multiple chunks by ids.",
          "operationId": "get_chunks_by_tracking_ids",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "X-API-Version",
              "in": "header",
              "description": "The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.",
              "required": false,
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/APIVersion"
                  }
                ],
                "nullable": true
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to get the chunks in the request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetTrackingChunksData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Chunks with one the ids which were specified",
              "content": {
                "application/json": {
                  "schema": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ChunkReturnTypes"
                    }
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to finding a chunk by tracking_id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/dataset": {
        "post": {
          "tags": [
            "Dataset"
          ],
          "summary": "Create dataset",
          "description": "Create a new dataset. The auth'ed user must be an owner of the organization to create a dataset.",
          "operationId": "create_dataset",
          "parameters": [
            {
              "name": "TR-Organization",
              "in": "header",
              "description": "The organization id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to create a new dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateDatasetRequest"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Dataset created successfully",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/Dataset"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to creating the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "owner"
              ]
            }
          ]
        },
        "put": {
          "tags": [
            "Dataset"
          ],
          "summary": "Update Dataset",
          "description": "Update a dataset. The auth'ed user must be an owner of the organization to update a dataset.",
          "operationId": "update_dataset",
          "parameters": [
            {
              "name": "TR-Organization",
              "in": "header",
              "description": "The organization id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to update a dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateDatasetRequest"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Dataset updated successfully",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/Dataset"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to updating the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Dataset not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "owner"
              ]
            }
          ]
        }
      },
      "/api/dataset/clear/{dataset_id}": {
        "put": {
          "tags": [
            "Dataset"
          ],
          "summary": "Clear Dataset",
          "description": "Clears a dataset. The auth'ed user must be an owner of the organization to clear a dataset.",
          "operationId": "clear_dataset",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "dataset_id",
              "in": "path",
              "description": "The id of the dataset you want to clear.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "204": {
              "description": "Dataset cleared successfully"
            },
            "400": {
              "description": "Service error relating to deleting the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Dataset not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "owner"
              ]
            }
          ]
        }
      },
      "/api/dataset/files/{dataset_id}/{page}": {
        "get": {
          "tags": [
            "File"
          ],
          "summary": "Get Files for Dataset",
          "description": "Get all files which belong to a given dataset specified by the dataset_id parameter. 10 files are returned per page.",
          "operationId": "get_dataset_files_handler",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "dataset_id",
              "in": "path",
              "description": "The id of the dataset to fetch files for.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "page",
              "in": "path",
              "description": "The page number of files you wish to fetch. Each page contains at most 10 files.",
              "required": true,
              "schema": {
                "type": "integer",
                "format": "int64",
                "minimum": 0
              }
            }
          ],
          "responses": {
            "200": {
              "description": "JSON body representing the files in the current dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/File"
                    }
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting the files in the current datase",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/dataset/groups/{dataset_id}/{page}": {
        "get": {
          "tags": [
            "Chunk Group"
          ],
          "summary": "Get Groups for Dataset",
          "description": "Fetch the groups which belong to a dataset specified by its id.",
          "operationId": "get_groups_for_dataset",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "dataset_id",
              "in": "path",
              "description": "The id of the dataset to fetch groups for.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "page",
              "in": "path",
              "description": "The page of groups to fetch. Page is 1-indexed.",
              "required": true,
              "schema": {
                "type": "integer",
                "format": "int64"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "JSON body representing the groups created by the given dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/GroupData"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting the groups created by the given dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/dataset/organization/{organization_id}": {
        "get": {
          "tags": [
            "Dataset"
          ],
          "summary": "Get Datasets from Organization",
          "description": "Get all datasets for an organization. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "get_datasets_from_organization",
          "parameters": [
            {
              "name": "TR-Organization",
              "in": "header",
              "description": "The organization id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "organization_id",
              "in": "path",
              "description": "id of the organization you want to reMayank datasets for",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "limit",
              "in": "query",
              "description": "The number of records to return",
              "required": false,
              "schema": {
                "type": "integer",
                "format": "int64",
                "nullable": true
              }
            },
            {
              "name": "offset",
              "in": "query",
              "description": "The number of records to skip",
              "required": false,
              "schema": {
                "type": "integer",
                "format": "int64",
                "nullable": true
              }
            }
          ],
          "responses": {
            "200": {
              "description": "Datasets reMayankd successfully",
              "content": {
                "application/json": {
                  "schema": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/DatasetAndUsage"
                    }
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to retrieving the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Could not find organization",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/dataset/tracking_id/{tracking_id}": {
        "delete": {
          "tags": [
            "Dataset"
          ],
          "summary": "Delete Dataset by Tracking ID",
          "description": "Delete a dataset by its tracking id. The auth'ed user must be an owner of the organization to delete a dataset.",
          "operationId": "delete_dataset_by_tracking_id",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "tracking_id",
              "in": "path",
              "description": "The tracking id of the dataset you want to delete.",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "responses": {
            "204": {
              "description": "Dataset deleted successfully"
            },
            "400": {
              "description": "Service error relating to deleting the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Dataset not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "owner"
              ]
            }
          ]
        }
      },
      "/api/dataset/usage/{dataset_id}": {
        "get": {
          "tags": [
            "Dataset"
          ],
          "summary": "Get Usage By Dataset ID",
          "description": "Get the usage for a dataset by its id.",
          "operationId": "get_usage_by_dataset_id",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "dataset_id",
              "in": "path",
              "description": "The id of the dataset you want to reMayank usage for.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "Dataset usage reMayankd successfully",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/DatasetUsageCount"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to retrieving the dataset usage",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Dataset not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/dataset/{dataset_id}": {
        "get": {
          "tags": [
            "Dataset"
          ],
          "summary": "Get Dataset",
          "description": "Get a dataset by id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "get_dataset",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "dataset_id",
              "in": "path",
              "description": "The id of the dataset you want to reMayank.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "Dataset reMayankd successfully",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/Dataset"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to retrieving the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Dataset not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        },
        "delete": {
          "tags": [
            "Dataset"
          ],
          "summary": "Delete Dataset",
          "description": "Delete a dataset. The auth'ed user must be an owner of the organization to delete a dataset.",
          "operationId": "delete_dataset",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "dataset_id",
              "in": "path",
              "description": "The id of the dataset you want to delete.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "204": {
              "description": "Dataset deleted successfully"
            },
            "400": {
              "description": "Service error relating to deleting the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Dataset not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "owner"
              ]
            }
          ]
        }
      },
      "/api/events": {
        "post": {
          "tags": [
            "Events"
          ],
          "summary": "Get events for the dataset",
          "description": "Get events for the dataset specified by the TR-Dataset header.",
          "operationId": "get_events",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to get events for a dataset",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetEventsData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Events for the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/EventReturn"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting events for the dataset",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/file": {
        "post": {
          "tags": [
            "File"
          ],
          "summary": "Upload File",
          "description": "Upload a file to S3 attached to the server. The file will be converted to HTML with tika and chunked algorithmically, images will be OCR'ed with tesseract. The resulting chunks will be indexed and searchable. Optionally, you can only upload the file and manually create chunks associated to the file after. See docs.Mayank.ai and/or contact us for more details and tips. Auth'ed user must be an admin or owner of the dataset's organization to upload a file.",
          "operationId": "upload_file_handler",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to upload a file",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UploadFileReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Confirmation that the file is uploading",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/UploadFileResult"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to uploading the file",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/file/{file_id}": {
        "get": {
          "tags": [
            "File"
          ],
          "summary": "Get File",
          "description": "Download a file based on its id.",
          "operationId": "get_file_handler",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "file_id",
              "in": "path",
              "description": "The id of the file to fetch",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "The signed s3 url corresponding to the file_id requested",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/FileDTO"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to finding the file",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "File not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        },
        "delete": {
          "tags": [
            "File"
          ],
          "summary": "Delete File",
          "description": "Delete a file from S3 attached to the server based on its id. This will disassociate chunks from the file, but only delete them all together if you specify delete_chunks to be true. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "delete_file_handler",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "file_id",
              "in": "path",
              "description": "The id of the file to delete",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "204": {
              "description": "Confirmation that the file has been deleted"
            },
            "400": {
              "description": "Service error relating to finding or deleting the file",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/health": {
        "get": {
          "tags": [
            "Health"
          ],
          "summary": "Health Check",
          "description": "Confirmation that the service is healthy and can make embedding vectors",
          "operationId": "health_check",
          "responses": {
            "200": {
              "description": "Confirmation that the service is healthy and can make embedding vectors"
            },
            "400": {
              "description": "Service error relating to making an embedding or overall service health",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          }
        }
      },
      "/api/invitation": {
        "post": {
          "tags": [
            "Invitation"
          ],
          "summary": "Send Invitation",
          "description": "Invitations act as a way to invite users to join an organization. After a user is invited, they will automatically be added to the organization with the role specified in the invitation once they set their. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "post_invitation",
          "parameters": [
            {
              "name": "TR-Organization",
              "in": "header",
              "description": "The organization id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to send an invitation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InvitationData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "204": {
              "description": "Ok response. Indicates that invitation email was sent correctly."
            },
            "400": {
              "description": "Invalid email or some other error",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/message": {
        "post": {
          "tags": [
            "Message"
          ],
          "summary": "Create message",
          "description": "Create message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions.Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "create_message",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to create a message completion",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateMessageReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "This will be a JSON response of a string containing the LLM's generated inference. Response if not streaming.",
              "content": {
                "text/plain": {
                  "schema": {
                    "type": "string"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting a chat completion",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        },
        "put": {
          "tags": [
            "Message"
          ],
          "summary": "Edit message",
          "description": "Edit message which exists within the topic's chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.Mayank.ai for more information. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "edit_message",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to edit a message and get a new stream",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EditMessageReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "This will be a HTTP stream, check the chat or search UI for an example how to process this"
            },
            "400": {
              "description": "Service error relating to getting a chat completion",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        },
        "delete": {
          "tags": [
            "Message"
          ],
          "summary": "Regenerate message",
          "description": "Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.Mayank.ai for more information. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "regenerate_message",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to delete an agent message then regenerate it in a strem",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegenerateMessageReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "This will be a JSON response of a string containing the LLM's generated inference. Response if not streaming.",
              "content": {
                "text/plain": {
                  "schema": {
                    "type": "string"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting a chat completion",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/messages/{messages_topic_id}": {
        "get": {
          "tags": [
            "Message"
          ],
          "summary": "Get all messages for a given topic",
          "description": "Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.Mayank.ai for more information.",
          "operationId": "get_all_topic_messages",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "messages_topic_id",
              "in": "path",
              "description": "The ID of the topic to get messages for.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "All messages relating to the topic with the given ID",
              "content": {
                "application/json": {
                  "schema": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/Message"
                    }
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting the messages",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/organization": {
        "post": {
          "tags": [
            "Organization"
          ],
          "summary": "Create Organization",
          "description": "Create a new organization. The auth'ed user who creates the organization will be the default owner of the organization.",
          "operationId": "create_organization",
          "requestBody": {
            "description": "The organization data that you want to create",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateOrganizationData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Created organization object",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/Organization"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to creating the organization",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        },
        "put": {
          "tags": [
            "Organization"
          ],
          "summary": "Update Organization",
          "description": "Update an organization. Only the owner of the organization can update it.",
          "operationId": "update_organization",
          "parameters": [
            {
              "name": "TR-Organization",
              "in": "header",
              "description": "The organization id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "The organization data that you want to update",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateOrganizationData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "Updated organization object",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/Organization"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to updating the organization",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "owner"
              ]
            }
          ]
        }
      },
      "/api/organization/usage/{organization_id}": {
        "get": {
          "tags": [
            "Organization"
          ],
          "summary": "Get Organization Usage",
          "description": "Fetch the current usage specification of an organization by its id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "get_organization_usage",
          "parameters": [
            {
              "name": "TR-Organization",
              "in": "header",
              "description": "The organization id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "organization_id",
              "in": "path",
              "description": "The id of the organization you want to fetch the usage of.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "The current usage of the specified organization",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/OrganizationUsageCount"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to finding the organization's usage by id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/organization/users/{organization_id}": {
        "get": {
          "tags": [
            "Organization"
          ],
          "summary": "Get Organization Users",
          "description": "Fetch the users of an organization by its id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "get_organization_users",
          "parameters": [
            {
              "name": "TR-Organization",
              "in": "header",
              "description": "The organization id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "organization_id",
              "in": "path",
              "description": "The id of the organization you want to fetch the users of.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "Array of users who belong to the specified by organization",
              "content": {
                "application/json": {
                  "schema": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/SlimUser"
                    }
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to finding the organization's users by id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/organization/{organization_id}": {
        "get": {
          "tags": [
            "Organization"
          ],
          "summary": "Get Organization",
          "description": "Fetch the details of an organization by its id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "get_organization",
          "parameters": [
            {
              "name": "TR-Organization",
              "in": "header",
              "description": "The organization id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "organization_id",
              "in": "path",
              "description": "The id of the organization you want to fetch.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "Organization with the id that was requested",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/Organization"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to finding the organization by id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            },
            "404": {
              "description": "Organization not found",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        },
        "delete": {
          "tags": [
            "Organization"
          ],
          "summary": "Delete Organization",
          "description": "Delete an organization by its id. The auth'ed user must be an owner of the organization to delete it.",
          "operationId": "delete_organization",
          "parameters": [
            {
              "name": "TR-Organization",
              "in": "header",
              "description": "The organization id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "organization_id",
              "in": "path",
              "description": "The id of the organization you want to fetch.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "204": {
              "description": "Confirmation that the organization was deleted"
            },
            "400": {
              "description": "Service error relating to deleting the organization by id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/stripe/checkout/setup/{organization_id}": {
        "post": {
          "tags": [
            "Stripe"
          ],
          "summary": "Create checkout session setup",
          "description": "Create a checkout session (setup)",
          "operationId": "create_setup_checkout_session",
          "parameters": [
            {
              "name": "organization_id",
              "in": "path",
              "description": "The id of the organization to create setup checkout session for.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "Checkout session (setup) response",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/CreateSetupCheckoutSessionResPayload"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to creating setup checkout session",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          }
        }
      },
      "/api/stripe/invoices/{organization_id}": {
        "get": {
          "tags": [
            "Stripe"
          ],
          "summary": "Get All Invoices",
          "description": "Get a list of all invoices",
          "operationId": "get_all_invoices",
          "parameters": [
            {
              "name": "organization_id",
              "in": "path",
              "description": "The id of the organization to get invoices for.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "List of all invoices",
              "content": {
                "application/json": {
                  "schema": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/StripeInvoice"
                    }
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting all invoices",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          }
        }
      },
      "/api/stripe/payment_link/{plan_id}/{organization_id}": {
        "get": {
          "tags": [
            "Stripe"
          ],
          "summary": "Checkout",
          "description": "Get a 303 SeeOther redirect link to the stripe checkout page for the plan and organization",
          "operationId": "direct_to_payment_link",
          "parameters": [
            {
              "name": "plan_id",
              "in": "path",
              "description": "id of the plan you want to subscribe to",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "organization_id",
              "in": "path",
              "description": "id of the organization you want to subscribe to the plan",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "303": {
              "description": "SeeOther response redirecting user to stripe checkout page"
            },
            "400": {
              "description": "Service error relating to creating a URL for a stripe checkout page",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          }
        }
      },
      "/api/stripe/plans": {
        "get": {
          "tags": [
            "Stripe"
          ],
          "summary": "Get All Plans",
          "description": "Get a list of all plans",
          "operationId": "get_all_plans",
          "responses": {
            "200": {
              "description": "List of all plans",
              "content": {
                "application/json": {
                  "schema": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/StripePlan"
                    }
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting all plans",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          }
        }
      },
      "/api/stripe/subscription/{subscription_id}": {
        "delete": {
          "tags": [
            "Stripe"
          ],
          "summary": "Cancel Subscription",
          "description": "Cancel a subscription by its id",
          "operationId": "cancel_subscription",
          "parameters": [
            {
              "name": "TR-Organization",
              "in": "header",
              "description": "The organization id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "subscription_id",
              "in": "path",
              "description": "id of the subscription you want to cancel",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "Confirmation that the subscription was cancelled"
            },
            "400": {
              "description": "Service error relating to creating a URL for a stripe checkout page",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "owner"
              ]
            }
          ]
        }
      },
      "/api/stripe/subscription_plan/{subscription_id}/{plan_id}": {
        "patch": {
          "tags": [
            "Stripe"
          ],
          "summary": "Update Subscription Plan",
          "description": "Update a subscription to a new plan",
          "operationId": "update_subscription_plan",
          "parameters": [
            {
              "name": "TR-Organization",
              "in": "header",
              "description": "The organization id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "subscription_id",
              "in": "path",
              "description": "id of the subscription you want to update",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "plan_id",
              "in": "path",
              "description": "id of the plan you want to subscribe to",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "Confirmation that the subscription was updated to the new plan"
            },
            "400": {
              "description": "Service error relating to updating the subscription to the new plan",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/topic": {
        "post": {
          "tags": [
            "Topic"
          ],
          "summary": "Create Topic",
          "description": "Create a new chat topic. Topics are attached to a owner_id's and act as a coordinator for conversation message history of gen-AI chat sessions. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "create_topic",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to create chat topic",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateTopicReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "The JSON response payload containing the created topic",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/Topic"
                  }
                }
              }
            },
            "400": {
              "description": "Topic name empty or a service error",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        },
        "put": {
          "tags": [
            "Topic"
          ],
          "summary": "Update Topic",
          "description": "Update an existing chat topic. Currently, only the name of the topic can be updated. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "update_topic",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "requestBody": {
            "description": "JSON request payload to update a chat topic",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateTopicReqPayload"
                }
              }
            },
            "required": true
          },
          "responses": {
            "204": {
              "description": "Confirmation that the topic was updated"
            },
            "400": {
              "description": "Service error relating to topic update",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/topic/owner/{owner_id}": {
        "get": {
          "tags": [
            "Topic"
          ],
          "summary": "Get All Topics for Owner ID",
          "description": "Get all topics belonging to an arbitary owner_id. This is useful for managing message history and chat sessions. It is common to use a browser fingerprint or your user's id as the owner_id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "get_all_topics_for_owner_id",
          "parameters": [
            {
              "name": "owner_id",
              "in": "path",
              "description": "The owner_id to get topics of; A common approach is to use a browser fingerprint or your user's id",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "All topics belonging to a given owner_id",
              "content": {
                "application/json": {
                  "schema": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/Topic"
                    }
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to getting topics for the owner_id",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/topic/{topic_id}": {
        "delete": {
          "tags": [
            "Topic"
          ],
          "summary": "Delete Topic",
          "description": "Delete an existing chat topic. When a topic is deleted, all associated chat messages are also deleted. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.",
          "operationId": "delete_topic",
          "parameters": [
            {
              "name": "TR-Dataset",
              "in": "header",
              "description": "The dataset id to use for the request",
              "required": true,
              "schema": {
                "type": "string"
              }
            },
            {
              "name": "topic_id",
              "in": "path",
              "description": "The id of the topic you want to delete.",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "204": {
              "description": "Confirmation that the topic was deleted"
            },
            "400": {
              "description": "Service error relating to topic deletion",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "admin"
              ]
            }
          ]
        }
      },
      "/api/user": {
        "put": {
          "tags": [
            "User"
          ],
          "summary": "Update User",
          "description": "Update a user's information. If the user_id is not provided, the auth'ed user will be updated. If the user_id is provided, the role of the auth'ed user or api key must be an admin (1) or owner (2) of the organization.",
          "operationId": "update_user",
          "requestBody": {
            "description": "JSON request payload to update user information for the auth'ed user",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateUserOrgRoleData"
                }
              }
            },
            "required": true
          },
          "responses": {
            "204": {
              "description": "Confirmation that the user's role was updated"
            },
            "400": {
              "description": "Service error relating to updating the user",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/user/api_key": {
        "post": {
          "tags": [
            "User"
          ],
          "summary": "Set User Api Key",
          "description": "Create a new api key for the auth'ed user. Successful response will contain the newly created api key. If a write role is assigned the api key will have permission level of the auth'ed user who calls this endpoint.",
          "operationId": "set_user_api_key",
          "requestBody": {
            "description": "JSON request payload to create a new user api key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SetUserApiKeyRequest"
                }
              }
            },
            "required": true
          },
          "responses": {
            "200": {
              "description": "JSON body representing the api_key for the user",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/SetUserApiKeyResponse"
                  }
                }
              }
            },
            "400": {
              "description": "Service error relating to creating api_key for the user",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/api/user/api_key/{api_key_id}": {
        "delete": {
          "tags": [
            "User"
          ],
          "summary": "Delete User Api Key",
          "description": "Delete an api key for the auth'ed user.",
          "operationId": "delete_user_api_key",
          "parameters": [
            {
              "name": "api_key_id",
              "in": "path",
              "description": "The id of the api key to delete",
              "required": true,
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "responses": {
            "204": {
              "description": "Confirmation that the api key was deleted"
            },
            "400": {
              "description": "Service error relating to creating api_key for the user",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "ApiKey": [
                "readonly"
              ]
            }
          ]
        }
      },
      "/metrics": {
        "post": {
          "tags": [
            "Metrics"
          ],
          "summary": "Get Prometheus Metrics",
          "description": "This route allows you to view the number of items in each queue in the Prometheus format.",
          "operationId": "get_metrics",
          "responses": {
            "200": {
              "description": "Prometheus metrics for the server",
              "content": {
                "text/plain": {
                  "schema": {
                    "type": "string"
                  }
                }
              }
            },
            "500": {
              "description": "Internal Server Error",
              "content": {
                "application/json": {
                  "schema": {
                    "$ref": "#/components/schemas/ErrorResponseBody"
                  }
                }
              }
            }
          },
          "security": [
            {
              "X-API-KEY": []
            }
          ]
        }
      }
    },
    "components": {
      "schemas": {
        "APIVersion": {
          "type": "string",
          "enum": [
            "V1",
            "V2"
          ]
        },
        "AddChunkToGroupData": {
          "type": "object",
          "properties": {
            "chunk_id": {
              "type": "string",
              "format": "uuid",
              "description": "Id of the chunk to make a member of the group.",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "description": "Tracking Id of the chunk to make a member of the group.",
              "nullable": true
            }
          }
        },
        "ApiKeyRespBody": {
          "type": "object",
          "required": [
            "id",
            "user_id",
            "name",
            "role",
            "created_at",
            "updated_at"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "dataset_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "nullable": true
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "organization_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "nullable": true
            },
            "role": {
              "type": "integer",
              "format": "int32"
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            },
            "user_id": {
              "type": "string",
              "format": "uuid"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_ids": [
              "d0d0d0d0-d0d0-d0d0-d0d0-d0d0d0d0d0d0"
            ],
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "name": "Mayank",
            "organization_ids": [
              "o1o1o1o1-o1o1-o1o1-o1o1-o1o1o1o1o1o1"
            ],
            "role": 1,
            "updated_at": "2021-01-01 00:00:00.000",
            "user_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3"
          }
        },
        "AuthQuery": {
          "type": "object",
          "properties": {
            "inv_code": {
              "type": "string",
              "format": "uuid",
              "description": "Code sent via email as a result of successful call to send_invitation",
              "nullable": true
            },
            "organization_id": {
              "type": "string",
              "format": "uuid",
              "description": "ID of organization to authenticate into",
              "nullable": true
            },
            "redirect_uri": {
              "type": "string",
              "description": "URL to redirect to after successful login",
              "nullable": true
            }
          },
          "example": {
            "inv_code": "00000000-0000-0000-0000-000000000000",
            "organization_id": "00000000-0000-0000-0000-000000000000",
            "redirect_uri": "https://api.Mayank.ai"
          }
        },
        "AutocompleteReqPayload": {
          "type": "object",
          "required": [
            "search_type",
            "query"
          ],
          "properties": {
            "content_only": {
              "type": "boolean",
              "description": "Set content_only to true to only returning the chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.",
              "nullable": true
            },
            "extend_results": {
              "type": "boolean",
              "description": "If specified to true, this will extend the search results to include non-exact prefix matches of the same search_type such that a full page_size of results are returned. Default is false.",
              "nullable": true
            },
            "filters": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ChunkFilter"
                }
              ],
              "nullable": true
            },
            "highlight_delimiters": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Set highlight_delimiters to a list of strings to use as delimiters for highlighting. If not specified, this defaults to [\"?\", \",\", \".\", \"!\"]. These are the characters that will be used to split the chunk_html into splits for highlighting.",
              "nullable": true
            },
            "highlight_max_length": {
              "type": "integer",
              "format": "int32",
              "description": "Set highlight_max_length to control the maximum number of tokens (typically whitespace separated strings, but sometimes also word stems) which can be present within a single highlight. If not specified, this defaults to 8. This is useful to shorten large splits which may have low scores due to length compared to the query. Set to something very large like 100 to highlight entire splits.",
              "nullable": true,
              "minimum": 0
            },
            "highlight_max_num": {
              "type": "integer",
              "format": "int32",
              "description": "Set highlight_max_num to control the maximum number of highlights per chunk. If not specified, this defaults to 3. It may be less than 3 if no snippets score above the highlight_threshold.",
              "nullable": true,
              "minimum": 0
            },
            "highlight_results": {
              "type": "boolean",
              "description": "Set highlight_results to false for a slight latency improvement (1-10ms). If not specified, this defaults to true. This will add `\u003Cb\u003E\u003Cmark\u003E` tags to the chunk_html of the chunks to highlight matching splits and return the highlights on each scored chunk in the response.",
              "nullable": true
            },
            "highlight_threshold": {
              "type": "number",
              "format": "double",
              "description": "Set highlight_threshold to a lower or higher value to adjust the sensitivity of the highlights applied to the chunk html. If not specified, this defaults to 0.8. The range is 0.0 to 1.0.",
              "nullable": true
            },
            "highlight_window": {
              "type": "integer",
              "format": "int32",
              "description": "Set highlight_window to a number to control the amount of words that are returned around the matched phrases. If not specified, this defaults to 0. This is useful for when you want to show more context around the matched words. When specified, window/2 whitespace separated words are added before and after each highlight in the response's highlights array. If an extended highlight overlaps with another highlight, the overlapping words are only included once.",
              "nullable": true,
              "minimum": 0
            },
            "location_bias": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/GeoInfoWithBias"
                }
              ],
              "nullable": true
            },
            "page_size": {
              "type": "integer",
              "format": "int64",
              "description": "Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.",
              "nullable": true,
              "minimum": 0
            },
            "query": {
              "type": "string",
              "description": "Query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set."
            },
            "recency_bias": {
              "type": "number",
              "format": "float",
              "description": "Recency Bias lets you determine how much of an effect the recency of chunks will have on the search results. If not specified, this defaults to 0.0. We recommend setting this to 1.0 for a gentle reranking of the results, \u003E3.0 for a strong reranking of the results.",
              "nullable": true
            },
            "score_threshold": {
              "type": "number",
              "format": "float",
              "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
              "nullable": true
            },
            "search_type": {
              "$ref": "#/components/schemas/SearchMethod"
            },
            "slim_chunks": {
              "type": "boolean",
              "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.",
              "nullable": true
            },
            "tag_weights": {
              "type": "object",
              "description": "Tag weights is a JSON object which can be used to boost the ranking of chunks with certain tags. This is useful for when you want to be able to bias towards chunks with a certain tag on the fly. The keys are the tag names and the values are the weights.",
              "additionalProperties": {
                "type": "number",
                "format": "float"
              },
              "nullable": true
            },
            "use_reranker": {
              "type": "boolean",
              "description": "If true, chunks will be reranked using scores from a cross encoder model. \"hybrid\" search will always use the reranker regardless of this setting.",
              "nullable": true
            },
            "use_weights": {
              "type": "boolean",
              "description": "Set use_weights to true to use the weights of the chunks in the result set in order to sort them. If not specified, this defaults to true.",
              "nullable": true
            }
          },
          "example": {
            "filters": {
              "must": [
                {
                  "field": "metadata.key2",
                  "match": [
                    "value3",
                    "value4"
                  ],
                  "range": {
                    "gt": 0,
                    "gte": 0,
                    "lt": 1,
                    "lte": 1
                  }
                }
              ],
              "must_not": [
                {
                  "field": "metadata.key3",
                  "match": [
                    "value5",
                    "value6"
                  ],
                  "range": {
                    "gt": 0,
                    "gte": 0,
                    "lt": 1,
                    "lte": 1
                  }
                }
              ],
              "should": [
                {
                  "field": "metadata.key1",
                  "match": [
                    "value1",
                    "value2"
                  ],
                  "range": {
                    "gt": 0,
                    "gte": 0,
                    "lt": 1,
                    "lte": 1
                  }
                }
              ]
            },
            "highlight_delimiters": [
              "?",
              ",",
              ".",
              "!"
            ],
            "highlight_results": true,
            "page": 1,
            "page_size": 10,
            "query": "Some search query",
            "recency_bias": 1,
            "score_threshold": 0.5,
            "search_type": "semantic",
            "use_weights": true
          }
        },
        "BatchQueuedChunkResponse": {
          "type": "object",
          "required": [
            "chunk_metadata",
            "pos_in_queue"
          ],
          "properties": {
            "chunk_metadata": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ChunkMetadata"
              }
            },
            "pos_in_queue": {
              "type": "integer",
              "format": "int32",
              "description": "The current position the last access item is in the queue"
            }
          },
          "example": {
            "chunk_metadata": [
              {
                "content": "Some content",
                "file_id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
                "link": "https://example.com",
                "metadata": {
                  "key1": "value1",
                  "key2": "value2"
                },
                "tag_set": [
                  "tag1",
                  "tag2"
                ],
                "time_stamp": "2021-01-01 00:00:00.000",
                "tracking_id": "tracking_id",
                "weight": 0.5
              },
              {
                "content": "Some content",
                "file_id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
                "link": "https://example.com",
                "metadata": {
                  "key1": "value1",
                  "key2": "value2"
                },
                "tag_set": [
                  "tag1",
                  "tag2"
                ],
                "time_stamp": "2021-01-01 00:00:00.000",
                "tracking_id": "tracking_id",
                "weight": 0.5
              }
            ],
            "pos_in_queue": 2
          }
        },
        "BookmarkGroupResponse": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/GetChunksForGroupsResponse"
            },
            {
              "$ref": "#/components/schemas/GroupsBookmarkQueryResult"
            }
          ]
        },
        "BookmarkGroupResult": {
          "type": "object",
          "required": [
            "chunk_uuid",
            "slim_groups"
          ],
          "properties": {
            "chunk_uuid": {
              "type": "string",
              "format": "uuid"
            },
            "slim_groups": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ChunkGroupAndFileId"
              }
            }
          }
        },
        "BoostPhrase": {
          "type": "object",
          "description": "Boost is useful for when you want to boost certain phrases in the fulltext search results for official listings. I.e. making sure that the listing for AirBNB itself ranks higher than companies who make software for AirBNB hosts by boosting the AirBNB token for its official listing.",
          "required": [
            "phrase",
            "boost_factor"
          ],
          "properties": {
            "boost_factor": {
              "type": "number",
              "format": "double",
              "description": "Amount to multiplicatevly increase the frequency of the tokens in the phrase by"
            },
            "phrase": {
              "type": "string",
              "description": "The phrase to boost in the fulltext document frequency index"
            }
          }
        },
        "ChatMessageProxy": {
          "type": "object",
          "required": [
            "role",
            "content"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "role": {
              "$ref": "#/components/schemas/RoleProxy"
            }
          },
          "example": {
            "content": "Hello, world!",
            "role": "user"
          }
        },
        "ChunkFilter": {
          "type": "object",
          "properties": {
            "jsonb_prefilter": {
              "type": "boolean",
              "description": "JOSNB prefilter tells the server to perform a full scan over the metadata JSONB column instead of using the filtered HNSW. Datasets on the enterprise plan with custom metadata indices will perform better with the filtered HNSW instead. When false, the server will use the filtered HNSW index to filter chunks. When true, the server will perform a full scan over the metadata JSONB column to filter chunks. Default is true.",
              "nullable": true
            },
            "must": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ConditionType"
              },
              "description": "All of these field conditions have to match for the chunk to be included in the result set.",
              "nullable": true
            },
            "must_not": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ConditionType"
              },
              "description": "None of these field conditions can match for the chunk to be included in the result set.",
              "nullable": true
            },
            "should": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ConditionType"
              },
              "description": "Only one of these field conditions has to match for the chunk to be included in the result set.",
              "nullable": true
            }
          },
          "example": {
            "must": [
              {
                "field": "metadata.key2",
                "match": [
                  "value3",
                  "value4"
                ],
                "range": {
                  "gt": 0,
                  "gte": 0,
                  "lt": 1,
                  "lte": 1
                }
              }
            ],
            "must_not": [
              {
                "field": "metadata.key3",
                "match": [
                  "value5",
                  "value6"
                ],
                "range": {
                  "gt": 0,
                  "gte": 0,
                  "lt": 1,
                  "lte": 1
                }
              }
            ],
            "should": [
              {
                "field": "metadata.key1",
                "match": [
                  "value1",
                  "value2"
                ],
                "range": {
                  "gt": 0,
                  "gte": 0,
                  "lt": 1,
                  "lte": 1
                }
              }
            ]
          }
        },
        "ChunkGroup": {
          "type": "object",
          "required": [
            "id",
            "name",
            "description",
            "created_at",
            "updated_at",
            "dataset_id"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "description": {
              "type": "string"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "metadata": {
              "nullable": true
            },
            "name": {
              "type": "string"
            },
            "tag_set": {
              "type": "array",
              "items": {
                "type": "string",
                "nullable": true
              },
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "nullable": true
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "name": "Mayank",
            "tracking_id": "3",
            "updated_at": "2021-01-01 00:00:00.000"
          }
        },
        "ChunkGroupAndFileId": {
          "type": "object",
          "required": [
            "id",
            "dataset_id",
            "name",
            "description",
            "created_at",
            "updated_at"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "description": {
              "type": "string"
            },
            "file_id": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "metadata": {
              "nullable": true
            },
            "name": {
              "type": "string"
            },
            "tag_set": {
              "type": "array",
              "items": {
                "type": "string",
                "nullable": true
              },
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "nullable": true
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "description": "A group of chunks",
            "file_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "name": "Mayank",
            "tracking_id": "3",
            "updated_at": "2021-01-01 00:00:00.000"
          }
        },
        "ChunkMetadata": {
          "type": "object",
          "title": "V2",
          "required": [
            "id",
            "qdrant_point_id",
            "created_at",
            "updated_at",
            "dataset_id",
            "weight"
          ],
          "properties": {
            "chunk_html": {
              "type": "string",
              "nullable": true
            },
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "image_urls": {
              "type": "array",
              "items": {
                "type": "string",
                "nullable": true
              },
              "nullable": true
            },
            "link": {
              "type": "string",
              "nullable": true
            },
            "location": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/GeoInfo"
                }
              ],
              "nullable": true
            },
            "metadata": {
              "nullable": true
            },
            "num_value": {
              "type": "number",
              "format": "double",
              "nullable": true
            },
            "qdrant_point_id": {
              "type": "string",
              "format": "uuid"
            },
            "tag_set": {
              "type": "array",
              "items": {
                "type": "string",
                "nullable": true
              },
              "nullable": true
            },
            "time_stamp": {
              "type": "string",
              "format": "date-time",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "nullable": true
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            },
            "weight": {
              "type": "number",
              "format": "double"
            }
          },
          "example": {
            "chunk_html": "\u003Cp\u003EHello, world!\u003C/p\u003E",
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "link": "https://Mayank.ai",
            "metadata": {
              "key": "value"
            },
            "qdrant_point_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "tag_set": "[tag1,tag2]",
            "time_stamp": "2021-01-01 00:00:00.000",
            "tracking_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "updated_at": "2021-01-01 00:00:00.000",
            "weight": 0.5
          }
        },
        "ChunkMetadataStringTagSet": {
          "type": "object",
          "title": "V1",
          "required": [
            "id",
            "qdrant_point_id",
            "created_at",
            "updated_at",
            "dataset_id",
            "weight"
          ],
          "properties": {
            "chunk_html": {
              "type": "string",
              "nullable": true
            },
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "image_urls": {
              "type": "array",
              "items": {
                "type": "string",
                "nullable": true
              },
              "nullable": true
            },
            "link": {
              "type": "string",
              "nullable": true
            },
            "location": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/GeoInfo"
                }
              ],
              "nullable": true
            },
            "metadata": {
              "nullable": true
            },
            "num_value": {
              "type": "number",
              "format": "double",
              "nullable": true
            },
            "qdrant_point_id": {
              "type": "string",
              "format": "uuid"
            },
            "tag_set": {
              "type": "string",
              "nullable": true
            },
            "time_stamp": {
              "type": "string",
              "format": "date-time",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "nullable": true
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            },
            "weight": {
              "type": "number",
              "format": "double"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "link": "https://Mayank.ai",
            "metadata": {
              "key": "value"
            },
            "qdrant_point_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "tag_set": "tag1,tag2",
            "time_stamp": "2021-01-01 00:00:00.000",
            "tracking_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "updated_at": "2021-01-01 00:00:00.000",
            "weight": 0.5
          }
        },
        "ChunkMetadataTypes": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/SlimChunkMetadata"
            },
            {
              "$ref": "#/components/schemas/ChunkMetadataStringTagSet"
            },
            {
              "$ref": "#/components/schemas/ContentChunkMetadata"
            }
          ]
        },
        "ChunkMetadataWithScore": {
          "type": "object",
          "title": "V1",
          "required": [
            "id",
            "qdrant_point_id",
            "created_at",
            "updated_at",
            "dataset_id",
            "weight",
            "score"
          ],
          "properties": {
            "chunk_html": {
              "type": "string",
              "nullable": true
            },
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "link": {
              "type": "string",
              "nullable": true
            },
            "metadata": {
              "nullable": true
            },
            "qdrant_point_id": {
              "type": "string",
              "format": "uuid"
            },
            "score": {
              "type": "number",
              "format": "float"
            },
            "tag_set": {
              "type": "string",
              "nullable": true
            },
            "time_stamp": {
              "type": "string",
              "format": "date-time",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "nullable": true
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            },
            "weight": {
              "type": "number",
              "format": "double"
            }
          },
          "example": {
            "chunk_html": "\u003Cp\u003EHello, world!\u003C/p\u003E",
            "content": "Hello, world!",
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "link": "https://Mayank.ai",
            "metadata": {
              "key": "value"
            },
            "qdrant_point_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "score": 0.9,
            "tag_set": "tag1,tag2",
            "time_stamp": "2021-01-01 00:00:00.000",
            "tracking_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "updated_at": "2021-01-01 00:00:00.000",
            "weight": 0.5
          }
        },
        "ChunkReqPayload": {
          "type": "object",
          "properties": {
            "boost_phrase": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/BoostPhrase"
                }
              ],
              "nullable": true
            },
            "chunk_html": {
              "type": "string",
              "description": "HTML content of the chunk. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content.",
              "nullable": true
            },
            "convert_html_to_text": {
              "type": "boolean",
              "description": "Convert HTML to raw text before processing to avoid adding noise to the vector embeddings. By default this is true. If you are using HTML content that you want to be included in the vector embeddings, set this to false.",
              "nullable": true
            },
            "distance_phrase": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/DistancePhrase"
                }
              ],
              "nullable": true
            },
            "group_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "Group ids are the ids of the groups that the chunk should be placed into. This is useful for when you want to create a chunk and add it to a group or multiple groups in one request. Necessary because this route queues the chunk for ingestion and the chunk may not exist yet immediately after response.",
              "nullable": true
            },
            "group_tracking_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Group tracking_ids are the tracking_ids of the groups that the chunk should be placed into. This is useful for when you want to create a chunk and add it to a group or multiple groups in one request. Necessary because this route queues the chunk for ingestion and the chunk may not exist yet immediately after response.",
              "nullable": true
            },
            "image_urls": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Image urls are a list of urls to images that are associated with the chunk. This is useful for when you want to associate images with a chunk.",
              "nullable": true
            },
            "link": {
              "type": "string",
              "description": "Link to the chunk. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation.",
              "nullable": true
            },
            "location": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/GeoInfo"
                }
              ],
              "nullable": true
            },
            "metadata": {
              "description": "Metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata.",
              "nullable": true
            },
            "num_value": {
              "type": "number",
              "format": "double",
              "description": "Num value is an arbitrary numerical value that can be used to filter chunks. This is useful for when you want to filter chunks by numerical value. There is no performance hit for filtering on num_value.",
              "nullable": true
            },
            "split_avg": {
              "type": "boolean",
              "description": "Split avg is a boolean which tells the server to split the text in the chunk_html into smaller chunks and average their resulting vectors. This is useful for when you want to create a chunk from a large piece of text and want to split it into smaller chunks to create a more fuzzy average dense vector. The sparse vector will be generated normally with no averaging. By default this is false.",
              "nullable": true
            },
            "tag_set": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tag set is a list of tags. This can be used to filter chunks by tag. Unlike with metadata filtering, HNSW indices will exist for each tag such that there is not a performance hit for filtering on them.",
              "nullable": true
            },
            "time_stamp": {
              "type": "string",
              "description": "Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results.",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "description": "Tracking_id is a string which can be used to identify a chunk. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.",
              "nullable": true
            },
            "upsert_by_tracking_id": {
              "type": "boolean",
              "description": "Upsert when a chunk with the same tracking_id exists. By default this is false, and the request will fail if a chunk with the same tracking_id exists. If this is true, the chunk will be updated if a chunk with the same tracking_id exists.",
              "nullable": true
            },
            "weight": {
              "type": "number",
              "format": "double",
              "description": "Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk's dataset dataset.",
              "nullable": true
            }
          },
          "example": {
            "boost_phrase": {
              "boost_factor": 5,
              "phrase": "foo"
            },
            "chunk_html": "\u003Cp\u003ESome HTML content\u003C/p\u003E",
            "distance_phrase": {
              "distance_factor": 0.5,
              "phrase": "flagship"
            },
            "group_ids": [
              "d290f1ee-6c54-4b01-90e6-d701748f0851"
            ],
            "group_tracking_ids": [
              "group_tracking_id"
            ],
            "image_urls": [
              "https://example.com/red",
              "https://example.com/blue"
            ],
            "link": "https://example.com",
            "location": {
              "lat": -34,
              "lon": 151
            },
            "metadata": {
              "key1": "value1",
              "key2": "value2"
            },
            "tag_set": [
              "tag1",
              "tag2"
            ],
            "time_stamp": "2021-01-01 00:00:00.000",
            "tracking_id": "tracking_id"
          }
        },
        "ChunkReturnTypes": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/ChunkMetadata"
            },
            {
              "$ref": "#/components/schemas/ChunkMetadataStringTagSet"
            }
          ]
        },
        "ClusterAnalytics": {
          "oneOf": [
            {
              "type": "object",
              "title": "ClusterTopics",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/ClusterAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "cluster_topics"
                  ]
                }
              }
            },
            {
              "type": "object",
              "title": "ClusterQueries",
              "required": [
                "cluster_id",
                "type"
              ],
              "properties": {
                "cluster_id": {
                  "type": "string",
                  "format": "uuid"
                },
                "page": {
                  "type": "integer",
                  "format": "int32",
                  "nullable": true,
                  "minimum": 0
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "cluster_queries"
                  ]
                }
              }
            }
          ],
          "discriminator": {
            "propertyName": "type"
          }
        },
        "ClusterAnalyticsFilter": {
          "type": "object",
          "properties": {
            "date_range": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/DateRange"
                }
              ],
              "nullable": true
            }
          }
        },
        "ClusterAnalyticsResponse": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/SearchClusterResponse"
            },
            {
              "$ref": "#/components/schemas/SearchQueryResponse"
            }
          ]
        },
        "ConditionType": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/FieldCondition"
            },
            {
              "$ref": "#/components/schemas/HasIDCondition"
            }
          ]
        },
        "ContentChunkMetadata": {
          "type": "object",
          "required": [
            "id",
            "qdrant_point_id",
            "weight"
          ],
          "properties": {
            "chunk_html": {
              "type": "string",
              "nullable": true
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "image_urls": {
              "type": "array",
              "items": {
                "type": "string",
                "nullable": true
              },
              "nullable": true
            },
            "num_value": {
              "type": "number",
              "format": "double",
              "nullable": true
            },
            "qdrant_point_id": {
              "type": "string",
              "format": "uuid"
            },
            "time_stamp": {
              "type": "string",
              "format": "date-time",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "nullable": true
            },
            "weight": {
              "type": "number",
              "format": "double"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "link": "https://Mayank.ai",
            "metadata": {
              "key": "value"
            },
            "qdrant_point_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "tag_set": "tag1,tag2",
            "time_stamp": "2021-01-01 00:00:00.000",
            "tracking_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "updated_at": "2021-01-01 00:00:00.000",
            "weight": 0.5
          }
        },
        "CountChunkQueryResponseBody": {
          "type": "object",
          "required": [
            "count"
          ],
          "properties": {
            "count": {
              "type": "integer",
              "format": "int32",
              "minimum": 0
            }
          }
        },
        "CountChunksReqPayload": {
          "type": "object",
          "required": [
            "search_type",
            "query"
          ],
          "properties": {
            "filters": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ChunkFilter"
                }
              ],
              "nullable": true
            },
            "limit": {
              "type": "integer",
              "format": "int64",
              "description": "Set limit to restrict the maximum number of chunks to count. This is useful for when you want to reduce the latency of the count operation. By default the limit will be the number of chunks in the dataset.",
              "nullable": true,
              "minimum": 0
            },
            "query": {
              "type": "string",
              "description": "Query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set."
            },
            "score_threshold": {
              "type": "number",
              "format": "float",
              "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
              "nullable": true
            },
            "search_type": {
              "$ref": "#/components/schemas/SearchMethod"
            }
          },
          "example": {
            "query": "Some search query",
            "score_threshold": 0.5,
            "search_type": "semantic"
          }
        },
        "CreateBatchChunkReqPayload": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/ChunkReqPayload"
          },
          "example": [
            {
              "chunk_html": "\u003Cp\u003ESome HTML content\u003C/p\u003E",
              "group_ids": [
                "d290f1ee-6c54-4b01-90e6-d701748f0851"
              ],
              "group_tracking_ids": [
                "group_tracking_id"
              ],
              "image_urls": [
                "https://example.com/red",
                "https://example.com/blue"
              ],
              "link": "https://example.com",
              "location": {
                "lat": -34,
                "lon": 151
              },
              "metadata": {
                "key1": "value1",
                "key2": "value2"
              },
              "tag_set": [
                "tag1",
                "tag2"
              ],
              "time_stamp": "2021-01-01 00:00:00.000",
              "tracking_id": "tracking_id",
              "upsert_by_tracking_id": true
            },
            {
              "chunk_html": "\u003Cp\u003ESome more HTML content\u003C/p\u003E",
              "group_ids": [
                "d290f1ee-6c54-4b01-90e6-d701748f0851"
              ],
              "group_tracking_ids": [
                "group_tracking_id"
              ],
              "image_urls": [],
              "link": "https://explain.com",
              "location": {
                "lat": -34,
                "lon": 151
              },
              "metadata": {
                "key1": "value1",
                "key2": "value2"
              },
              "tag_set": [
                "tag3",
                "tag4"
              ],
              "time_stamp": "2021-01-01 00:00:00.000",
              "tracking_id": "tracking_id",
              "upsert_by_tracking_id": true,
              "weight": 0.5
            }
          ]
        },
        "CreateChunkGroupReqPayload": {
          "type": "object",
          "properties": {
            "description": {
              "type": "string",
              "description": "Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for.",
              "nullable": true
            },
            "metadata": {
              "description": "Optional metadata to assign to the chunk_group. This is a JSON object that can store any additional information you want to associate with the chunks inside of the chunk_group.",
              "nullable": true
            },
            "name": {
              "type": "string",
              "description": "Name to assign to the chunk_group. Does not need to be unique.",
              "nullable": true
            },
            "tag_set": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional tags to assign to the chunk_group. This is a list of strings that can be used to categorize the chunks inside the chunk_group.",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "description": "Optional tracking id to assign to the chunk_group. This is a unique identifier for the chunk_group.",
              "nullable": true
            },
            "upsert_by_tracking_id": {
              "type": "boolean",
              "description": "Upsert when a chunk_group with the same tracking_id exists. By default this is false, and the request will fail if a chunk_group with the same tracking_id exists. If this is true, the chunk_group will be updated if a chunk_group with the same tracking_id exists.",
              "nullable": true
            }
          }
        },
        "CreateChunkReqPayloadEnum": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/CreateSingleChunkReqPayload"
            },
            {
              "$ref": "#/components/schemas/CreateBatchChunkReqPayload"
            }
          ]
        },
        "CreateDatasetRequest": {
          "type": "object",
          "required": [
            "dataset_name",
            "organization_id",
            "server_configuration",
            "client_configuration"
          ],
          "properties": {
            "client_configuration": {
              "description": "Client configuration for the dataset, can be arbitrary JSON. We recommend setting to `{}` to start. See docs.Mayank.ai for more information or adjust with the admin dashboard."
            },
            "dataset_name": {
              "type": "string",
              "description": "Name of the dataset."
            },
            "organization_id": {
              "type": "string",
              "format": "uuid",
              "description": "Organization ID that the dataset will belong to."
            },
            "server_configuration": {
              "description": "Server configuration for the dataset, can be arbitrary JSON. We recommend setting to `{}` to start. See docs.Mayank.ai for more information or adjust with the admin dashboard."
            },
            "tracking_id": {
              "type": "string",
              "description": "Optional tracking ID for the dataset. Can be used to track the dataset in external systems. Must be unique within the organization.",
              "nullable": true
            }
          },
          "example": {
            "client_configuration": {
  
            },
            "dataset_name": "My Dataset",
            "organization_id": "00000000-0000-0000-0000-000000000000",
            "server_configuration": {
  
            }
          }
        },
        "CreateMessageReqPayload": {
          "type": "object",
          "required": [
            "new_message_content",
            "topic_id"
          ],
          "properties": {
            "completion_first": {
              "type": "boolean",
              "description": "Completion first decides whether the stream should contain the stream of the completion response or the chunks first. Default is false. Keep in mind that || is used to separate the chunks from the completion response. If || is in the completion then you may want to split on ||{ instead.",
              "nullable": true
            },
            "concat_user_messages_query": {
              "type": "boolean",
              "description": "If concat user messages query is set to true, all of the user messages in the topic will be concatenated together and used as the search query. If not specified, this defaults to false. Default is false.",
              "nullable": true
            },
            "filters": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ChunkFilter"
                }
              ],
              "nullable": true
            },
            "frequency_penalty": {
              "type": "number",
              "format": "float",
              "description": "Frequency penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. Default is 0.7.",
              "nullable": true
            },
            "highlight_delimiters": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The delimiters to use for highlighting the citations. If this is not included, the default delimiters will be used. Default is `[\".\", \"!\", \"?\", \"\\n\", \"\\t\", \",\"]`.",
              "nullable": true
            },
            "highlight_results": {
              "type": "boolean",
              "description": "Set highlight_results to false for a slight latency improvement (1-10ms). If not specified, this defaults to true. This will add `\u003Cb\u003E\u003Cmark\u003E` tags to the chunk_html of the chunks to highlight matching splits and return the highlights on each scored chunk in the response.",
              "nullable": true
            },
            "max_tokens": {
              "type": "integer",
              "format": "int32",
              "description": "The maximum number of tokens to generate in the chat completion. Default is None.",
              "nullable": true,
              "minimum": 0
            },
            "new_message_content": {
              "type": "string",
              "description": "The content of the user message to attach to the topic and then generate an assistant message in response to."
            },
            "page_size": {
              "type": "integer",
              "format": "int64",
              "description": "Page size is the number of chunks to fetch during RAG. If 0, then no search will be performed. If specified, this will override the N retrievals to include in the dataset configuration. Default is None.",
              "nullable": true,
              "minimum": 0
            },
            "presence_penalty": {
              "type": "number",
              "format": "float",
              "description": "Presence penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics. Default is 0.7.",
              "nullable": true
            },
            "score_threshold": {
              "type": "number",
              "format": "float",
              "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
              "nullable": true
            },
            "search_query": {
              "type": "string",
              "description": "Query is the search query. This can be any string. The search_query will be used to create a dense embedding vector and/or sparse vector which will be used to find the result set. If not specified, will default to the last user message or HyDE if HyDE is enabled in the dataset configuration. Default is None.",
              "nullable": true
            },
            "search_type": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/SearchMethod"
                }
              ],
              "nullable": true
            },
            "stop_tokens": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Stop tokens are up to 4 sequences where the API will stop generating further tokens. Default is None.",
              "nullable": true
            },
            "stream_response": {
              "type": "boolean",
              "description": "Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.",
              "nullable": true
            },
            "system_prompt": {
              "type": "string",
              "description": "Optionally, override the system prompt in dataset server settings.",
              "nullable": true
            },
            "temperature": {
              "type": "number",
              "format": "float",
              "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. Default is 0.5.",
              "nullable": true
            },
            "topic_id": {
              "type": "string",
              "format": "uuid",
              "description": "The ID of the topic to attach the message to."
            }
          }
        },
        "CreateOrganizationData": {
          "type": "object",
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "type": "string",
              "description": "The arbitrary name which will be used to identify the organization. This name must be unique."
            }
          }
        },
        "CreateSetupCheckoutSessionResPayload": {
          "type": "object",
          "required": [
            "url"
          ],
          "properties": {
            "url": {
              "type": "string"
            }
          }
        },
        "CreateSingleChunkReqPayload": {
          "$ref": "#/components/schemas/ChunkReqPayload"
        },
        "CreateTopicReqPayload": {
          "type": "object",
          "required": [
            "owner_id"
          ],
          "properties": {
            "first_user_message": {
              "type": "string",
              "description": "The first message which will belong to the topic. The topic name is generated based on this message similar to how it works in the OpenAI chat UX if a name is not explicitly provided on the name request body key.",
              "nullable": true
            },
            "name": {
              "type": "string",
              "description": "The name of the topic. If this is not provided, the topic name is generated from the first_user_message.",
              "nullable": true
            },
            "owner_id": {
              "type": "string",
              "description": "The owner_id of the topic. This is typically a browser fingerprint or your user's id. It is used to group topics together for a user."
            }
          }
        },
        "Dataset": {
          "type": "object",
          "required": [
            "id",
            "name",
            "created_at",
            "updated_at",
            "organization_id",
            "server_configuration",
            "deleted"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "deleted": {
              "type": "integer",
              "format": "int32"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "organization_id": {
              "type": "string",
              "format": "uuid"
            },
            "server_configuration": {
  
            },
            "tracking_id": {
              "type": "string",
              "nullable": true
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "name": "Mayank",
            "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "server_configuration": {
              "key": "value"
            },
            "tracking_id": "3",
            "updated_at": "2021-01-01 00:00:00.000"
          }
        },
        "DatasetAnalytics": {
          "type": "object",
          "required": [
            "total_queries",
            "search_rps",
            "avg_latency",
            "p99",
            "p95",
            "p50"
          ],
          "properties": {
            "avg_latency": {
              "type": "number",
              "format": "double"
            },
            "p50": {
              "type": "number",
              "format": "double"
            },
            "p95": {
              "type": "number",
              "format": "double"
            },
            "p99": {
              "type": "number",
              "format": "double"
            },
            "search_rps": {
              "type": "number",
              "format": "double"
            },
            "total_queries": {
              "type": "integer",
              "format": "int32"
            }
          }
        },
        "DatasetAndUsage": {
          "type": "object",
          "required": [
            "dataset",
            "dataset_usage"
          ],
          "properties": {
            "dataset": {
              "$ref": "#/components/schemas/DatasetDTO"
            },
            "dataset_usage": {
              "$ref": "#/components/schemas/DatasetUsageCount"
            }
          },
          "example": {
            "dataset": {
              "client_configuration": {
                "key": "value"
              },
              "created_at": "2021-01-01 00:00:00.000",
              "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
              "name": "Mayank",
              "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
              "updated_at": "2021-01-01 00:00:00.000"
            },
            "dataset_usage": {
              "chunk_count": 100,
              "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
              "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3"
            }
          }
        },
        "DatasetDTO": {
          "type": "object",
          "required": [
            "id",
            "name",
            "created_at",
            "updated_at",
            "organization_id"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "organization_id": {
              "type": "string",
              "format": "uuid"
            },
            "tracking_id": {
              "type": "string",
              "nullable": true
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "name": "Mayank",
            "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "tracking_id": "3",
            "updated_at": "2021-01-01 00:00:00.000"
          }
        },
        "DatasetUsageCount": {
          "type": "object",
          "required": [
            "id",
            "dataset_id",
            "chunk_count"
          ],
          "properties": {
            "chunk_count": {
              "type": "integer",
              "format": "int32"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            }
          },
          "example": {
            "chunk_count": 100,
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3"
          }
        },
        "DateRange": {
          "type": "object",
          "properties": {
            "gt": {
              "type": "string",
              "nullable": true
            },
            "gte": {
              "type": "string",
              "nullable": true
            },
            "lt": {
              "type": "string",
              "nullable": true
            },
            "lte": {
              "type": "string",
              "nullable": true
            }
          },
          "example": {
            "gt": "2021-01-01 00:00:00.000",
            "gte": "2021-01-01 00:00:00.000",
            "lt": "2021-01-01 00:00:00.000",
            "lte": "2021-01-01 00:00:00.000"
          }
        },
        "DeleteTopicData": {
          "type": "object",
          "required": [
            "topic_id"
          ],
          "properties": {
            "topic_id": {
              "type": "string",
              "format": "uuid",
              "description": "The id of the topic to target."
            }
          }
        },
        "DeleteUserApiKeyRequest": {
          "type": "object",
          "required": [
            "api_key_id"
          ],
          "properties": {
            "api_key_id": {
              "type": "string",
              "format": "uuid",
              "description": "The id of the api key to delete."
            }
          }
        },
        "DeprecatedSearchOverGroupsResponseBody": {
          "type": "object",
          "title": "V1",
          "required": [
            "group_chunks",
            "total_chunk_pages"
          ],
          "properties": {
            "group_chunks": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/GroupScoreChunk"
              }
            },
            "total_chunk_pages": {
              "type": "integer",
              "format": "int64"
            }
          }
        },
        "DistancePhrase": {
          "type": "object",
          "description": "Distance is useful for when you want to boost certain phrases in the fulltext search results for official listings. I.e. making sure that the listing for AirBNB itself ranks higher than companies who make software for AirBNB hosts by boosting the AirBNB token for its official listing.",
          "required": [
            "phrase",
            "distance_factor"
          ],
          "properties": {
            "distance_factor": {
              "type": "number",
              "format": "float",
              "description": "Amount to multiplicatevly increase the frequency of the tokens in the phrase by"
            },
            "phrase": {
              "type": "string",
              "description": "The phrase to boost in the fulltext document frequency index"
            }
          }
        },
        "EditMessageReqPayload": {
          "type": "object",
          "required": [
            "topic_id",
            "message_sort_order",
            "new_message_content"
          ],
          "properties": {
            "completion_first": {
              "type": "boolean",
              "description": "Completion first decides whether the stream should contain the stream of the completion response or the chunks first. Default is false. Keep in mind that || is used to separate the chunks from the completion response. If || is in the completion then you may want to split on ||{ instead.",
              "nullable": true
            },
            "concat_user_messages_query": {
              "type": "boolean",
              "description": "If concat user messages query is set to true, all of the user messages in the topic will be concatenated together and used as the search query. If not specified, this defaults to false. Default is false.",
              "nullable": true
            },
            "filters": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ChunkFilter"
                }
              ],
              "nullable": true
            },
            "frequency_penalty": {
              "type": "number",
              "format": "float",
              "description": "Frequency penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. Default is 0.7.",
              "nullable": true
            },
            "highlight_citations": {
              "type": "boolean",
              "description": "Whether or not to highlight the citations in the response. If this is set to true or not included, the citations will be highlighted. If this is set to false, the citations will not be highlighted. Default is true.",
              "nullable": true
            },
            "highlight_delimiters": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The delimiters to use for highlighting the citations. If this is not included, the default delimiters will be used. Default is `[\".\", \"!\", \"?\", \"\\n\", \"\\t\", \",\"]`.",
              "nullable": true
            },
            "max_tokens": {
              "type": "integer",
              "format": "int32",
              "description": "The maximum number of tokens to generate in the chat completion.",
              "nullable": true,
              "minimum": 0
            },
            "message_sort_order": {
              "type": "integer",
              "format": "int32",
              "description": "The sort order of the message to edit."
            },
            "new_message_content": {
              "type": "string",
              "description": "The new content of the message to replace the old content with."
            },
            "page_size": {
              "type": "integer",
              "format": "int64",
              "description": "Page size is the number of chunks to fetch during RAG. If 0, then no search will be performed. If specified, this will override the N retrievals to include in the dataset configuration. Default is None.",
              "nullable": true,
              "minimum": 0
            },
            "presence_penalty": {
              "type": "number",
              "format": "float",
              "description": "Presence penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.",
              "nullable": true
            },
            "score_threshold": {
              "type": "number",
              "format": "float",
              "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
              "nullable": true
            },
            "search_query": {
              "type": "string",
              "description": "Query is the search query. This can be any string. The search_query will be used to create a dense embedding vector and/or sparse vector which will be used to find the result set. If not specified, will default to the last user message or HyDE if HyDE is enabled in the dataset configuration. Default is None.",
              "nullable": true
            },
            "search_type": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/SearchMethod"
                }
              ],
              "nullable": true
            },
            "stop_tokens": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Stop tokens are up to 4 sequences where the API will stop generating further tokens.",
              "nullable": true
            },
            "stream_response": {
              "type": "boolean",
              "description": "Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.",
              "nullable": true
            },
            "system_prompt": {
              "type": "string",
              "description": "Optionally, override the system prompt in dataset server settings.",
              "nullable": true
            },
            "temperature": {
              "type": "number",
              "format": "float",
              "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. Default is 0.7.",
              "nullable": true
            },
            "topic_id": {
              "type": "string",
              "format": "uuid",
              "description": "The id of the topic to edit the message at the given sort order for."
            }
          }
        },
        "ErrorResponseBody": {
          "type": "object",
          "required": [
            "message"
          ],
          "properties": {
            "message": {
              "type": "string"
            }
          },
          "example": {
            "message": "Bad Request"
          }
        },
        "Event": {
          "type": "object",
          "required": [
            "id",
            "created_at",
            "dataset_id",
            "event_type",
            "event_data"
          ],
          "properties": {
            "created_at": {
              "type": "string"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "event_data": {
              "type": "string"
            },
            "event_type": {
              "type": "string"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "event_data": {
              "file_name": "file.txt",
              "group_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3"
            },
            "event_type": "file_uploaded",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "updated_at": "2021-01-01 00:00:00.000"
          }
        },
        "EventReturn": {
          "type": "object",
          "required": [
            "events",
            "page_count"
          ],
          "properties": {
            "events": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Event"
              }
            },
            "page_count": {
              "type": "integer",
              "format": "int32"
            }
          }
        },
        "EventTypeRequest": {
          "type": "string",
          "enum": [
            "file_uploaded",
            "file_upload_failed",
            "chunks_uploaded",
            "chunk_action_failed",
            "chunk_updated",
            "bulk_chunks_deleted",
            "dataset_delete_failed",
            "qdrant_upload_failed",
            "bulk_chunk_upload_failed",
            "group_chunks_updated",
            "group_chunks_action_failed"
          ]
        },
        "FieldCondition": {
          "type": "object",
          "required": [
            "field"
          ],
          "properties": {
            "date_range": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/DateRange"
                }
              ],
              "nullable": true
            },
            "field": {
              "type": "string",
              "description": "Field is the name of the field to filter on. The field value will be used to check for an exact substring match on the metadata values for each existing chunk. This is useful for when you want to filter chunks by arbitrary metadata. To access fields inside of the metadata that you provide with the card, prefix the field name with `metadata.`."
            },
            "geo_bounding_box": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/LocationBoundingBox"
                }
              ],
              "nullable": true
            },
            "geo_polygon": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/LocationPolygon"
                }
              ],
              "nullable": true
            },
            "geo_radius": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/LocationRadius"
                }
              ],
              "nullable": true
            },
            "match": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/MatchCondition"
              },
              "description": "Match is the value to match on the field. The match value will be used to check for an exact substring match on the metadata values for each existing chunk. This is useful for when you want to filter chunks by arbitrary metadata.",
              "nullable": true
            },
            "range": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/Range"
                }
              ],
              "nullable": true
            }
          },
          "example": {
            "field": "metadata.key1",
            "match": [
              "value1",
              "value2"
            ],
            "range": {
              "gt": 0,
              "gte": 0,
              "lt": 1,
              "lte": 1
            }
          }
        },
        "File": {
          "type": "object",
          "required": [
            "id",
            "file_name",
            "created_at",
            "updated_at",
            "size",
            "dataset_id"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "file_name": {
              "type": "string"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "link": {
              "type": "string",
              "nullable": true
            },
            "metadata": {
              "nullable": true
            },
            "size": {
              "type": "integer",
              "format": "int64"
            },
            "tag_set": {
              "type": "array",
              "items": {
                "type": "string",
                "nullable": true
              },
              "nullable": true
            },
            "time_stamp": {
              "type": "string",
              "format": "date-time",
              "nullable": true
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "file_name": "file.txt",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "link": "https://Mayank.ai",
            "metadata": {
              "key": "value"
            },
            "size": 1000,
            "tag_set": "tag1,tag2",
            "time_stamp": "2021-01-01 00:00:00.000",
            "updated_at": "2021-01-01 00:00:00.000"
          }
        },
        "FileDTO": {
          "type": "object",
          "required": [
            "id",
            "file_name",
            "created_at",
            "updated_at",
            "size",
            "s3_url"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "file_name": {
              "type": "string"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "link": {
              "type": "string",
              "nullable": true
            },
            "metadata": {
              "nullable": true
            },
            "s3_url": {
              "type": "string"
            },
            "size": {
              "type": "integer",
              "format": "int64"
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "file_name": "file.txt",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "link": "https://Mayank.ai",
            "metadata": {
              "key": "value"
            },
            "s3_url": "https://Mayank.ai",
            "size": 1000,
            "updated_at": "2021-01-01 00:00:00.000"
          }
        },
        "GenerateChunksRequest": {
          "type": "object",
          "required": [
            "prev_messages",
            "chunk_ids"
          ],
          "properties": {
            "chunk_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "The ids of the chunks to be reMayankd and injected into the context window for RAG."
            },
            "frequency_penalty": {
              "type": "number",
              "format": "float",
              "description": "Frequency penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. Default is 0.7.",
              "nullable": true
            },
            "highlight_results": {
              "type": "boolean",
              "description": "Set highlight_results to false for a slight latency improvement (1-10ms). If not specified, this defaults to true. This will add `\u003Cb\u003E\u003Cmark\u003E`` tags to the chunk_html of the chunks to highlight matching splits.",
              "nullable": true
            },
            "max_tokens": {
              "type": "integer",
              "format": "int32",
              "description": "The maximum number of tokens to generate in the chat completion. Default is None.",
              "nullable": true,
              "minimum": 0
            },
            "presence_penalty": {
              "type": "number",
              "format": "float",
              "description": "Presence penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics. Default is 0.7.",
              "nullable": true
            },
            "prev_messages": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ChatMessageProxy"
              },
              "description": "The previous messages to be placed into the chat history. The last message in this array will be the prompt for the model to inference on. The length of this array must be at least 1."
            },
            "prompt": {
              "type": "string",
              "description": "Prompt for the last message in the prev_messages array. This will be used to generate the next message in the chat. The default is 'Respond to the instruction and include the doc numbers that you used in square brackets at the end of the sentences that you used the docs for:'. You can also specify an empty string to leave the final message alone such that your user's final message can be used as the prompt. See docs.Mayank.ai or contact us for more information.",
              "nullable": true
            },
            "stop_tokens": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Stop tokens are up to 4 sequences where the API will stop generating further tokens. Default is None.",
              "nullable": true
            },
            "stream_response": {
              "type": "boolean",
              "description": "Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.",
              "nullable": true
            },
            "temperature": {
              "type": "number",
              "format": "float",
              "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. Default is 0.5.",
              "nullable": true
            }
          },
          "example": {
            "chunk_ids": [
              "d290f1ee-6c54-4b01-90e6-d701748f0851"
            ],
            "model": "text-embedding-small",
            "prev_messages": [
              {
                "content": "I am going to provide several pieces of information (docs) for you to use in response to a request or question.",
                "role": "user"
              }
            ],
            "prompt": "Respond to the instruction and include the doc numbers that you used in square brackets at the end of the sentences that you used the docs for:",
            "stream_response": true
          }
        },
        "GeoInfo": {
          "type": "object",
          "required": [
            "lat",
            "lon"
          ],
          "properties": {
            "lat": {
              "$ref": "#/components/schemas/GeoTypes"
            },
            "lon": {
              "$ref": "#/components/schemas/GeoTypes"
            }
          }
        },
        "GeoInfoWithBias": {
          "type": "object",
          "required": [
            "location",
            "bias"
          ],
          "properties": {
            "bias": {
              "type": "number",
              "format": "double"
            },
            "location": {
              "$ref": "#/components/schemas/GeoInfo"
            }
          }
        },
        "GeoTypes": {
          "oneOf": [
            {
              "type": "integer",
              "format": "int64"
            },
            {
              "type": "number",
              "format": "double"
            }
          ]
        },
        "GetChunksData": {
          "type": "object",
          "required": [
            "ids"
          ],
          "properties": {
            "ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              }
            }
          }
        },
        "GetChunksForGroupsResponse": {
          "type": "object",
          "title": "V2",
          "required": [
            "chunks",
            "group",
            "total_pages"
          ],
          "properties": {
            "chunks": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ChunkMetadata"
              }
            },
            "group": {
              "$ref": "#/components/schemas/ChunkGroupAndFileId"
            },
            "total_pages": {
              "type": "integer",
              "format": "int64",
              "minimum": 0
            }
          }
        },
        "GetDatasetsPagination": {
          "type": "object",
          "properties": {
            "limit": {
              "type": "integer",
              "format": "int64",
              "nullable": true
            },
            "offset": {
              "type": "integer",
              "format": "int64",
              "nullable": true
            }
          }
        },
        "GetEventsData": {
          "type": "object",
          "properties": {
            "event_types": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/EventTypeRequest"
              },
              "description": "The types of events to get. Any combination of file_uploaded, chunk_uploaded, chunk_action_failed, chunk_updated, or qdrant_index_failed. Leave undefined to get all events.",
              "nullable": true
            },
            "page": {
              "type": "integer",
              "format": "int64",
              "description": "The page number to get. Default is 1.",
              "nullable": true
            },
            "page_size": {
              "type": "integer",
              "format": "int64",
              "description": "The number of items per page. Default is 10.",
              "nullable": true
            }
          },
          "example": {
            "page": 1,
            "page_size": 10,
            "type": [
              "chunk_action_failed"
            ]
          }
        },
        "GetGroupsForChunksData": {
          "type": "object",
          "required": [
            "chunk_ids"
          ],
          "properties": {
            "chunk_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              }
            }
          }
        },
        "GetTrackingChunksData": {
          "type": "object",
          "required": [
            "tracking_ids"
          ],
          "properties": {
            "tracking_ids": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "Granularity": {
          "type": "string",
          "enum": [
            "minute",
            "second",
            "hour",
            "day"
          ]
        },
        "GroupData": {
          "type": "object",
          "required": [
            "groups",
            "total_pages"
          ],
          "properties": {
            "groups": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ChunkGroupAndFileId"
              }
            },
            "total_pages": {
              "type": "integer",
              "format": "int32"
            }
          }
        },
        "GroupScoreChunk": {
          "type": "object",
          "title": "V1",
          "required": [
            "group_id",
            "group_created_at",
            "group_updated_at",
            "group_dataset_id",
            "metadata"
          ],
          "properties": {
            "file_id": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            },
            "group_created_at": {
              "type": "string",
              "format": "date-time"
            },
            "group_dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "group_description": {
              "type": "string",
              "nullable": true
            },
            "group_id": {
              "type": "string",
              "format": "uuid"
            },
            "group_metadata": {
              "nullable": true
            },
            "group_name": {
              "type": "string",
              "nullable": true
            },
            "group_tag_set": {
              "type": "array",
              "items": {
                "type": "string",
                "nullable": true
              },
              "nullable": true
            },
            "group_tracking_id": {
              "type": "string",
              "nullable": true
            },
            "group_updated_at": {
              "type": "string",
              "format": "date-time"
            },
            "metadata": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ScoreChunkDTO"
              }
            }
          }
        },
        "GroupsBookmarkQueryResult": {
          "type": "object",
          "title": "V1",
          "required": [
            "chunks",
            "group",
            "total_pages"
          ],
          "properties": {
            "chunks": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ChunkMetadataStringTagSet"
              }
            },
            "group": {
              "$ref": "#/components/schemas/ChunkGroupAndFileId"
            },
            "total_pages": {
              "type": "integer",
              "format": "int64",
              "minimum": 0
            }
          }
        },
        "HasIDCondition": {
          "type": "object",
          "properties": {
            "ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "nullable": true
            },
            "tracking_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "nullable": true
            }
          }
        },
        "HeadQueries": {
          "type": "object",
          "required": [
            "query",
            "count"
          ],
          "properties": {
            "count": {
              "type": "integer",
              "format": "int64"
            },
            "query": {
              "type": "string"
            }
          }
        },
        "HeadQueryResponse": {
          "type": "object",
          "required": [
            "queries"
          ],
          "properties": {
            "queries": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/HeadQueries"
              }
            }
          }
        },
        "InvitationData": {
          "type": "object",
          "required": [
            "organization_id",
            "user_role",
            "email",
            "app_url",
            "redirect_uri"
          ],
          "properties": {
            "app_url": {
              "type": "string",
              "description": "The url of the app that the user will be directed to in order to set their password. Usually admin.Mayank.ai, but may differ for local dev or self-hosted setups."
            },
            "email": {
              "type": "string",
              "description": "The email of the user to invite. Must be a valid email as they will be sent an email to register."
            },
            "organization_id": {
              "type": "string",
              "format": "uuid",
              "description": "The id of the organization to invite the user to."
            },
            "redirect_uri": {
              "type": "string",
              "description": "The url that the user will be redirected to after setting their password."
            },
            "user_role": {
              "type": "integer",
              "format": "int32",
              "description": "The role the user will have in the organization. 0 = User, 1 = Admin, 2 = Owner."
            }
          }
        },
        "LatencyGraphResponse": {
          "type": "object",
          "required": [
            "latency_points"
          ],
          "properties": {
            "latency_points": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SearchLatencyGraph"
              }
            }
          }
        },
        "LocationBoundingBox": {
          "type": "object",
          "required": [
            "top_left",
            "bottom_right"
          ],
          "properties": {
            "bottom_right": {
              "$ref": "#/components/schemas/GeoInfo"
            },
            "top_left": {
              "$ref": "#/components/schemas/GeoInfo"
            }
          }
        },
        "LocationPolygon": {
          "type": "object",
          "required": [
            "exterior"
          ],
          "properties": {
            "exterior": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/GeoInfo"
              }
            },
            "interior": {
              "type": "array",
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/GeoInfo"
                }
              },
              "nullable": true
            }
          }
        },
        "LocationRadius": {
          "type": "object",
          "required": [
            "center",
            "radius"
          ],
          "properties": {
            "center": {
              "$ref": "#/components/schemas/GeoInfo"
            },
            "radius": {
              "type": "number",
              "format": "double"
            }
          }
        },
        "MatchCondition": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "integer",
              "format": "int64"
            },
            {
              "type": "number",
              "format": "double"
            }
          ]
        },
        "Message": {
          "type": "object",
          "required": [
            "id",
            "topic_id",
            "sort_order",
            "content",
            "role",
            "deleted",
            "created_at",
            "updated_at",
            "dataset_id"
          ],
          "properties": {
            "completion_tokens": {
              "type": "integer",
              "format": "int32",
              "nullable": true
            },
            "content": {
              "type": "string"
            },
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "deleted": {
              "type": "boolean"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "prompt_tokens": {
              "type": "integer",
              "format": "int32",
              "nullable": true
            },
            "role": {
              "type": "string"
            },
            "sort_order": {
              "type": "integer",
              "format": "int32"
            },
            "topic_id": {
              "type": "string",
              "format": "uuid"
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            }
          },
          "example": {
            "completion_tokens": 300,
            "content": "Hello, world!",
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "deleted": false,
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "prompt_tokens": 300,
            "role": "user",
            "sort_order": 1,
            "topic_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "updated_at": "2021-01-01 00:00:00.000"
          }
        },
        "NewChunkMetadataTypes": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/SlimChunkMetadataWithArrayTagSet"
            },
            {
              "$ref": "#/components/schemas/ChunkMetadata"
            },
            {
              "$ref": "#/components/schemas/ContentChunkMetadata"
            }
          ]
        },
        "Organization": {
          "type": "object",
          "required": [
            "id",
            "name",
            "created_at",
            "updated_at",
            "deleted"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "deleted": {
              "type": "integer",
              "format": "int32"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "registerable": {
              "type": "boolean",
              "nullable": true
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "name": "Mayank",
            "registerable": true,
            "updated_at": "2021-01-01 00:00:00.000"
          }
        },
        "OrganizationUsageCount": {
          "type": "object",
          "required": [
            "id",
            "org_id",
            "dataset_count",
            "user_count",
            "file_storage",
            "message_count",
            "chunk_count"
          ],
          "properties": {
            "chunk_count": {
              "type": "integer",
              "format": "int32"
            },
            "dataset_count": {
              "type": "integer",
              "format": "int32"
            },
            "file_storage": {
              "type": "integer",
              "format": "int64"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "message_count": {
              "type": "integer",
              "format": "int32"
            },
            "org_id": {
              "type": "string",
              "format": "uuid"
            },
            "user_count": {
              "type": "integer",
              "format": "int32"
            }
          },
          "example": {
            "chunk_count": 1000,
            "dataset_count": 1,
            "file_storage": 512,
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "message_count": 1000,
            "org_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "user_count": 5
          }
        },
        "QueryCountResponse": {
          "type": "object",
          "required": [
            "total_queries"
          ],
          "properties": {
            "total_queries": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SearchTypeCount"
              }
            }
          }
        },
        "RAGAnalytics": {
          "oneOf": [
            {
              "type": "object",
              "title": "RAGQueries",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/RAGAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "page": {
                  "type": "integer",
                  "format": "int32",
                  "nullable": true,
                  "minimum": 0
                },
                "sort_by": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SortBy"
                    }
                  ],
                  "nullable": true
                },
                "sort_order": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SortOrder"
                    }
                  ],
                  "nullable": true
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "rag_queries"
                  ]
                }
              }
            },
            {
              "type": "object",
              "title": "RAGUsage",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/RAGAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "rag_usage"
                  ]
                }
              }
            }
          ],
          "discriminator": {
            "propertyName": "type"
          }
        },
        "RAGAnalyticsFilter": {
          "type": "object",
          "properties": {
            "date_range": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/DateRange"
                }
              ],
              "nullable": true
            },
            "rag_type": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RagTypes"
                }
              ],
              "nullable": true
            }
          }
        },
        "RAGAnalyticsResponse": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/RagQueryResponse"
            },
            {
              "$ref": "#/components/schemas/RAGUsageResponse"
            }
          ]
        },
        "RAGUsageResponse": {
          "type": "object",
          "required": [
            "total_queries"
          ],
          "properties": {
            "total_queries": {
              "type": "integer",
              "format": "int32",
              "minimum": 0
            }
          }
        },
        "RPSGraphResponse": {
          "type": "object",
          "required": [
            "rps_points"
          ],
          "properties": {
            "rps_points": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SearchRPSGraph"
              }
            }
          }
        },
        "RagQueryEvent": {
          "type": "object",
          "required": [
            "id",
            "rag_type",
            "user_message",
            "search_id",
            "results",
            "dataset_id",
            "created_at"
          ],
          "properties": {
            "created_at": {
              "type": "string"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "rag_type": {
              "type": "string"
            },
            "results": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ChunkMetadataStringTagSet"
              }
            },
            "search_id": {
              "type": "string",
              "format": "uuid"
            },
            "user_message": {
              "type": "string"
            }
          }
        },
        "RagQueryResponse": {
          "type": "object",
          "required": [
            "queries"
          ],
          "properties": {
            "queries": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RagQueryEvent"
              }
            }
          }
        },
        "RagTypes": {
          "type": "string",
          "enum": [
            "chosen_chunks",
            "all_chunks"
          ]
        },
        "Range": {
          "type": "object",
          "properties": {
            "gt": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RangeCondition"
                }
              ],
              "nullable": true
            },
            "gte": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RangeCondition"
                }
              ],
              "nullable": true
            },
            "lt": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RangeCondition"
                }
              ],
              "nullable": true
            },
            "lte": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RangeCondition"
                }
              ],
              "nullable": true
            }
          },
          "example": {
            "gt": 0,
            "gte": 0,
            "lt": 1,
            "lte": 1
          }
        },
        "RangeCondition": {
          "oneOf": [
            {
              "type": "number",
              "format": "double"
            },
            {
              "type": "integer",
              "format": "int64"
            }
          ]
        },
        "RecommendChunksRequest": {
          "type": "object",
          "properties": {
            "filters": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ChunkFilter"
                }
              ],
              "nullable": true
            },
            "limit": {
              "type": "integer",
              "format": "int64",
              "description": "The number of chunks to return. This is the number of chunks which will be returned in the response. The default is 10.",
              "nullable": true,
              "minimum": 0
            },
            "negative_chunk_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "The ids of the chunks to be used as negative examples for the recommendation. The chunks in this array will be used to filter out similar chunks.",
              "nullable": true
            },
            "negative_tracking_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The tracking_ids of the chunks to be used as negative examples for the recommendation. The chunks in this array will be used to filter out similar chunks.",
              "nullable": true
            },
            "positive_chunk_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "The ids of the chunks to be used as positive examples for the recommendation. The chunks in this array will be used to find similar chunks.",
              "nullable": true
            },
            "positive_tracking_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The tracking_ids of the chunks to be used as positive examples for the recommendation. The chunks in this array will be used to find similar chunks.",
              "nullable": true
            },
            "recommend_type": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RecommendType"
                }
              ],
              "nullable": true
            },
            "slim_chunks": {
              "type": "boolean",
              "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.",
              "nullable": true
            },
            "strategy": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RecommendationStrategy"
                }
              ],
              "nullable": true
            }
          }
        },
        "RecommendChunksResponseBody": {
          "type": "object",
          "title": "V2",
          "required": [
            "chunks"
          ],
          "properties": {
            "chunks": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ScoreChunk"
              }
            }
          }
        },
        "RecommendGroupChunksRequest": {
          "type": "object",
          "properties": {
            "filters": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ChunkFilter"
                }
              ],
              "nullable": true
            },
            "group_size": {
              "type": "integer",
              "format": "int32",
              "description": "The number of chunks to fetch for each group. This is the number of chunks which will be returned in the response for each group. The default is 3. If this is set to a large number, we recommend setting slim_chunks to true to avoid returning the content and chunk_html of the chunks so as to reduce latency due to content download and serialization.",
              "nullable": true,
              "minimum": 0
            },
            "limit": {
              "type": "integer",
              "format": "int64",
              "description": "The number of groups to return. This is the number of groups which will be returned in the response. The default is 10.",
              "nullable": true,
              "minimum": 0
            },
            "negative_group_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "The ids of the groups to be used as negative examples for the recommendation. The groups in this array will be used to filter out similar groups.",
              "nullable": true
            },
            "negative_group_tracking_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The ids of the groups to be used as negative examples for the recommendation. The groups in this array will be used to filter out similar groups.",
              "nullable": true
            },
            "positive_group_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "The ids of the groups to be used as positive examples for the recommendation. The groups in this array will be used to find similar groups.",
              "nullable": true
            },
            "positive_group_tracking_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The ids of the groups to be used as positive examples for the recommendation. The groups in this array will be used to find similar groups.",
              "nullable": true
            },
            "recommend_type": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RecommendType"
                }
              ],
              "nullable": true
            },
            "slim_chunks": {
              "type": "boolean",
              "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.",
              "nullable": true
            },
            "strategy": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RecommendationStrategy"
                }
              ],
              "nullable": true
            }
          }
        },
        "RecommendGroupsResponse": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/RecommendGroupsResponseBody"
            },
            {
              "$ref": "#/components/schemas/GroupScoreChunk"
            }
          ]
        },
        "RecommendGroupsResponseBody": {
          "type": "object",
          "title": "V2",
          "required": [
            "results"
          ],
          "properties": {
            "results": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SearchOverGroupsResults"
              }
            }
          }
        },
        "RecommendResponseTypes": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/RecommendChunksResponseBody"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ChunkMetadataWithScore"
              }
            }
          ]
        },
        "RecommendType": {
          "type": "string",
          "enum": [
            "semantic",
            "full_text"
          ]
        },
        "RecommendationAnalytics": {
          "oneOf": [
            {
              "type": "object",
              "title": "LowConfidenceRecommendations",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/RecommendationAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "page": {
                  "type": "integer",
                  "format": "int32",
                  "nullable": true,
                  "minimum": 0
                },
                "threshold": {
                  "type": "number",
                  "format": "float",
                  "nullable": true
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "low_confidence_recommendations"
                  ]
                }
              }
            },
            {
              "type": "object",
              "title": "RecommendationQueries",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/RecommendationAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "page": {
                  "type": "integer",
                  "format": "int32",
                  "nullable": true,
                  "minimum": 0
                },
                "sort_by": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SortBy"
                    }
                  ],
                  "nullable": true
                },
                "sort_order": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SortOrder"
                    }
                  ],
                  "nullable": true
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "recommendation_queries"
                  ]
                }
              }
            }
          ],
          "discriminator": {
            "propertyName": "type"
          }
        },
        "RecommendationAnalyticsFilter": {
          "type": "object",
          "properties": {
            "date_range": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/DateRange"
                }
              ],
              "nullable": true
            },
            "recommendation_type": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RecommendationType"
                }
              ],
              "nullable": true
            }
          }
        },
        "RecommendationAnalyticsResponse": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/RecommendationsEventResponse"
            },
            {
              "$ref": "#/components/schemas/RecommendationsEventResponse"
            }
          ]
        },
        "RecommendationEvent": {
          "type": "object",
          "required": [
            "id",
            "recommendation_type",
            "positive_ids",
            "negative_ids",
            "positive_tracking_ids",
            "negative_tracking_ids",
            "request_params",
            "results",
            "top_score",
            "dataset_id",
            "created_at"
          ],
          "properties": {
            "created_at": {
              "type": "string"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "negative_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              }
            },
            "negative_tracking_ids": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "positive_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              }
            },
            "positive_tracking_ids": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "recommendation_type": {
              "type": "string"
            },
            "request_params": {
              "type": "string"
            },
            "results": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SearchResultType"
              }
            },
            "top_score": {
              "type": "number",
              "format": "float"
            }
          }
        },
        "RecommendationStrategy": {
          "type": "string",
          "enum": [
            "average_vector",
            "best_score"
          ]
        },
        "RecommendationType": {
          "type": "string",
          "enum": [
            "Chunk",
            "Group"
          ]
        },
        "RecommendationsEventResponse": {
          "type": "object",
          "required": [
            "queries"
          ],
          "properties": {
            "queries": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/RecommendationEvent"
              }
            }
          }
        },
        "RegenerateMessageReqPayload": {
          "type": "object",
          "required": [
            "topic_id"
          ],
          "properties": {
            "completion_first": {
              "type": "boolean",
              "description": "Completion first decides whether the stream should contain the stream of the completion response or the chunks first. Default is false. Keep in mind that || is used to separate the chunks from the completion response. If || is in the completion then you may want to split on ||{ instead.",
              "nullable": true
            },
            "concat_user_messages_query": {
              "type": "boolean",
              "description": "If concat user messages query is set to true, all of the user messages in the topic will be concatenated together and used as the search query. If not specified, this defaults to false. Default is false.",
              "nullable": true
            },
            "filters": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ChunkFilter"
                }
              ],
              "nullable": true
            },
            "frequency_penalty": {
              "type": "number",
              "format": "float",
              "description": "Frequency penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. Default is 0.7.",
              "nullable": true
            },
            "highlight_citations": {
              "type": "boolean",
              "description": "Whether or not to highlight the citations in the response. If this is set to true or not included, the citations will be highlighted. If this is set to false, the citations will not be highlighted. Default is true.",
              "nullable": true
            },
            "highlight_delimiters": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The delimiters to use for highlighting the citations. If this is not included, the default delimiters will be used. Default is `[\".\", \"!\", \"?\", \"\\n\", \"\\t\", \",\"]`.",
              "nullable": true
            },
            "max_tokens": {
              "type": "integer",
              "format": "int32",
              "description": "The maximum number of tokens to generate in the chat completion.",
              "nullable": true,
              "minimum": 0
            },
            "page_size": {
              "type": "integer",
              "format": "int64",
              "description": "Page size is the number of chunks to fetch during RAG. If 0, then no search will be performed. If specified, this will override the N retrievals to include in the dataset configuration. Default is None.",
              "nullable": true,
              "minimum": 0
            },
            "presence_penalty": {
              "type": "number",
              "format": "float",
              "description": "Presence penalty is a number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.",
              "nullable": true
            },
            "score_threshold": {
              "type": "number",
              "format": "float",
              "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
              "nullable": true
            },
            "search_query": {
              "type": "string",
              "description": "Query is the search query. This can be any string. The search_query will be used to create a dense embedding vector and/or sparse vector which will be used to find the result set. If not specified, will default to the last user message or HyDE if HyDE is enabled in the dataset configuration. Default is None.",
              "nullable": true
            },
            "search_type": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/SearchMethod"
                }
              ],
              "nullable": true
            },
            "stop_tokens": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Stop tokens are up to 4 sequences where the API will stop generating further tokens.",
              "nullable": true
            },
            "stream_response": {
              "type": "boolean",
              "description": "Whether or not to stream the response. If this is set to true or not included, the response will be a stream. If this is set to false, the response will be a normal JSON response. Default is true.",
              "nullable": true
            },
            "temperature": {
              "type": "number",
              "format": "float",
              "description": "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. Default is 0.7.",
              "nullable": true
            },
            "topic_id": {
              "type": "string",
              "format": "uuid",
              "description": "The id of the topic to regenerate the last message for."
            }
          }
        },
        "RemoveChunkFromGroupReqPayload": {
          "type": "object",
          "required": [
            "chunk_id"
          ],
          "properties": {
            "chunk_id": {
              "type": "string",
              "format": "uuid",
              "description": "Id of the chunk to remove from the group."
            }
          }
        },
        "ReturnQueuedChunk": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/SingleQueuedChunkResponse"
            },
            {
              "$ref": "#/components/schemas/BatchQueuedChunkResponse"
            }
          ]
        },
        "RoleProxy": {
          "type": "string",
          "enum": [
            "system",
            "user",
            "assistant"
          ]
        },
        "ScoreChunk": {
          "type": "object",
          "title": "V2",
          "required": [
            "chunk",
            "score"
          ],
          "properties": {
            "chunk": {
              "$ref": "#/components/schemas/NewChunkMetadataTypes"
            },
            "highlights": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "nullable": true
            },
            "score": {
              "type": "number",
              "format": "float"
            }
          },
          "example": {
            "chunk": {
              "chunk_html": "\u003Cp\u003ESome HTML content\u003C/p\u003E",
              "content": "Some content",
              "id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
              "link": "https://example.com",
              "metadata": {
                "key1": "value1",
                "key2": "value2"
              },
              "time_stamp": "2021-01-01 00:00:00.000",
              "weight": 0.5
            },
            "highlights": [
              "highlight is two tokens: high, light",
              "whereas hello is only one token: hello"
            ],
            "score": 0.5
          }
        },
        "ScoreChunkDTO": {
          "type": "object",
          "required": [
            "metadata",
            "score"
          ],
          "properties": {
            "highlights": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "nullable": true
            },
            "metadata": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ChunkMetadataTypes"
              }
            },
            "score": {
              "type": "number",
              "format": "double"
            }
          },
          "example": {
            "highlights": [
              "highlight is two tokens: high, light",
              "whereas hello is only one token: hello"
            ],
            "metadata": [
              {
                "chunk_html": "\u003Cp\u003ESome HTML content\u003C/p\u003E",
                "content": "Some content",
                "id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
                "link": "https://example.com",
                "metadata": {
                  "key1": "value1",
                  "key2": "value2"
                },
                "time_stamp": "2021-01-01 00:00:00.000",
                "weight": 0.5
              }
            ],
            "score": 0.5
          }
        },
        "SearchAnalytics": {
          "oneOf": [
            {
              "type": "object",
              "title": "LatencyGraph",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SearchAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "granularity": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/Granularity"
                    }
                  ],
                  "nullable": true
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "latency_graph"
                  ]
                }
              }
            },
            {
              "type": "object",
              "title": "RPSGraph",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SearchAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "granularity": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/Granularity"
                    }
                  ],
                  "nullable": true
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "rps_graph"
                  ]
                }
              }
            },
            {
              "type": "object",
              "title": "SearchMetrics",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SearchAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "search_metrics"
                  ]
                }
              }
            },
            {
              "type": "object",
              "title": "HeadQueries",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SearchAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "page": {
                  "type": "integer",
                  "format": "int32",
                  "nullable": true,
                  "minimum": 0
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "head_queries"
                  ]
                }
              }
            },
            {
              "type": "object",
              "title": "LowConfidenceQueries",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SearchAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "page": {
                  "type": "integer",
                  "format": "int32",
                  "nullable": true,
                  "minimum": 0
                },
                "threshold": {
                  "type": "number",
                  "format": "float",
                  "nullable": true
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "low_confidence_queries"
                  ]
                }
              }
            },
            {
              "type": "object",
              "title": "NoResultQueries",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SearchAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "page": {
                  "type": "integer",
                  "format": "int32",
                  "nullable": true,
                  "minimum": 0
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "no_result_queries"
                  ]
                }
              }
            },
            {
              "type": "object",
              "title": "SearchQueries",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SearchAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "page": {
                  "type": "integer",
                  "format": "int32",
                  "nullable": true,
                  "minimum": 0
                },
                "sort_by": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SortBy"
                    }
                  ],
                  "nullable": true
                },
                "sort_order": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SortOrder"
                    }
                  ],
                  "nullable": true
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "search_queries"
                  ]
                }
              }
            },
            {
              "type": "object",
              "title": "CountQueries",
              "required": [
                "type"
              ],
              "properties": {
                "filter": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SearchAnalyticsFilter"
                    }
                  ],
                  "nullable": true
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "count_queries"
                  ]
                }
              }
            },
            {
              "type": "object",
              "title": "QueryDetails",
              "required": [
                "search_id",
                "type"
              ],
              "properties": {
                "search_id": {
                  "type": "string",
                  "format": "uuid"
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "query_details"
                  ]
                }
              }
            }
          ],
          "discriminator": {
            "propertyName": "type"
          }
        },
        "SearchAnalyticsFilter": {
          "type": "object",
          "properties": {
            "date_range": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/DateRange"
                }
              ],
              "nullable": true
            },
            "search_method": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/SearchMethod"
                }
              ],
              "nullable": true
            },
            "search_type": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/SearchType"
                }
              ],
              "nullable": true
            }
          }
        },
        "SearchAnalyticsResponse": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/LatencyGraphResponse"
            },
            {
              "$ref": "#/components/schemas/RPSGraphResponse"
            },
            {
              "$ref": "#/components/schemas/DatasetAnalytics"
            },
            {
              "$ref": "#/components/schemas/HeadQueryResponse"
            },
            {
              "$ref": "#/components/schemas/SearchQueryResponse"
            },
            {
              "$ref": "#/components/schemas/SearchQueryResponse"
            },
            {
              "$ref": "#/components/schemas/SearchQueryResponse"
            },
            {
              "$ref": "#/components/schemas/QueryCountResponse"
            },
            {
              "$ref": "#/components/schemas/SearchQueryEvent"
            }
          ]
        },
        "SearchChunkQueryResponseBody": {
          "type": "object",
          "title": "V1",
          "required": [
            "score_chunks",
            "total_chunk_pages"
          ],
          "properties": {
            "score_chunks": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ScoreChunkDTO"
              }
            },
            "total_chunk_pages": {
              "type": "integer",
              "format": "int64"
            }
          }
        },
        "SearchChunksReqPayload": {
          "type": "object",
          "required": [
            "search_type",
            "query"
          ],
          "properties": {
            "content_only": {
              "type": "boolean",
              "description": "Set content_only to true to only returning the chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.",
              "nullable": true
            },
            "filters": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ChunkFilter"
                }
              ],
              "nullable": true
            },
            "get_total_pages": {
              "type": "boolean",
              "description": "Get total page count for the query accounting for the applied filters. Defaults to false, but can be set to true when the latency penalty is acceptable (typically 50-200ms).",
              "nullable": true
            },
            "highlight_delimiters": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Set highlight_delimiters to a list of strings to use as delimiters for highlighting. If not specified, this defaults to [\"?\", \",\", \".\", \"!\"]. These are the characters that will be used to split the chunk_html into splits for highlighting. These are the characters that will be used to split the chunk_html into splits for highlighting.",
              "nullable": true
            },
            "highlight_max_length": {
              "type": "integer",
              "format": "int32",
              "description": "Set highlight_max_length to control the maximum number of tokens (typically whitespace separated strings, but sometimes also word stems) which can be present within a single highlight. If not specified, this defaults to 8. This is useful to shorten large splits which may have low scores due to length compared to the query. Set to something very large like 100 to highlight entire splits.",
              "nullable": true,
              "minimum": 0
            },
            "highlight_max_num": {
              "type": "integer",
              "format": "int32",
              "description": "Set highlight_max_num to control the maximum number of highlights per chunk. If not specified, this defaults to 3. It may be less than 3 if no snippets score above the highlight_threshold.",
              "nullable": true,
              "minimum": 0
            },
            "highlight_results": {
              "type": "boolean",
              "description": "Set highlight_results to false for a slight latency improvement (1-10ms). If not specified, this defaults to true. This will add `\u003Cb\u003E\u003Cmark\u003E` tags to the chunk_html of the chunks to highlight matching splits and return the highlights on each scored chunk in the response.",
              "nullable": true
            },
            "highlight_threshold": {
              "type": "number",
              "format": "double",
              "description": "Set highlight_threshold to a lower or higher value to adjust the sensitivity of the highlights applied to the chunk html. If not specified, this defaults to 0.8. The range is 0.0 to 1.0.",
              "nullable": true
            },
            "highlight_window": {
              "type": "integer",
              "format": "int32",
              "description": "Set highlight_window to a number to control the amount of words that are returned around the matched phrases. If not specified, this defaults to 0. This is useful for when you want to show more context around the matched words. When specified, window/2 whitespace separated words are added before and after each highlight in the response's highlights array. If an extended highlight overlaps with another highlight, the overlapping words are only included once.",
              "nullable": true,
              "minimum": 0
            },
            "location_bias": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/GeoInfoWithBias"
                }
              ],
              "nullable": true
            },
            "page": {
              "type": "integer",
              "format": "int64",
              "description": "Page of chunks to fetch. Page is 1-indexed.",
              "nullable": true,
              "minimum": 0
            },
            "page_size": {
              "type": "integer",
              "format": "int64",
              "description": "Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.",
              "nullable": true,
              "minimum": 0
            },
            "query": {
              "type": "string",
              "description": "Query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set."
            },
            "recency_bias": {
              "type": "number",
              "format": "float",
              "description": "Recency Bias lets you determine how much of an effect the recency of chunks will have on the search results. If not specified, this defaults to 0.0. We recommend setting this to 1.0 for a gentle reranking of the results, \u003E3.0 for a strong reranking of the results.",
              "nullable": true
            },
            "score_threshold": {
              "type": "number",
              "format": "float",
              "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
              "nullable": true
            },
            "search_type": {
              "$ref": "#/components/schemas/SearchMethod"
            },
            "slim_chunks": {
              "type": "boolean",
              "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.",
              "nullable": true
            },
            "tag_weights": {
              "type": "object",
              "description": "Tag weights is a JSON object which can be used to boost the ranking of chunks with certain tags. This is useful for when you want to be able to bias towards chunks with a certain tag on the fly. The keys are the tag names and the values are the weights.",
              "additionalProperties": {
                "type": "number",
                "format": "float"
              },
              "nullable": true
            },
            "use_reranker": {
              "type": "boolean",
              "description": "If true, chunks will be reranked using scores from a cross encoder model. \"hybrid\" search will always use the reranker regardless of this setting.",
              "nullable": true
            },
            "use_weights": {
              "type": "boolean",
              "description": "Set use_weights to true to use the weights of the chunks in the result set in order to sort them. If not specified, this defaults to true.",
              "nullable": true
            }
          },
          "example": {
            "filters": {
              "must": [
                {
                  "field": "num_value",
                  "range": {
                    "gt": 0,
                    "gte": 0,
                    "lt": 1,
                    "lte": 1
                  }
                }
              ],
              "must_not": [
                {
                  "field": "metadata.key3",
                  "match": [
                    "value5",
                    "value6"
                  ]
                }
              ],
              "should": [
                {
                  "field": "metadata.key1",
                  "match": [
                    "value1",
                    "value2"
                  ]
                }
              ]
            },
            "highlight_delimiters": [
              "?",
              ",",
              ".",
              "!"
            ],
            "highlight_results": true,
            "page": 1,
            "page_size": 10,
            "query": "Some search query",
            "recency_bias": 1,
            "score_threshold": 0.5,
            "search_type": "semantic",
            "use_weights": true
          }
        },
        "SearchClusterResponse": {
          "type": "object",
          "required": [
            "clusters"
          ],
          "properties": {
            "clusters": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SearchClusterTopics"
              }
            }
          }
        },
        "SearchClusterTopics": {
          "type": "object",
          "required": [
            "id",
            "dataset_id",
            "topic",
            "density",
            "avg_score",
            "created_at"
          ],
          "properties": {
            "avg_score": {
              "type": "number",
              "format": "float"
            },
            "created_at": {
              "type": "string"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "density": {
              "type": "integer",
              "format": "int32"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "topic": {
              "type": "string"
            }
          }
        },
        "SearchGroupResponseTypes": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/SearchWithinGroupResponseBody"
            },
            {
              "$ref": "#/components/schemas/SearchWithinGroupResults"
            }
          ]
        },
        "SearchLatencyGraph": {
          "type": "object",
          "required": [
            "time_stamp",
            "average_latency"
          ],
          "properties": {
            "average_latency": {
              "type": "number",
              "format": "double"
            },
            "time_stamp": {
              "type": "string"
            }
          }
        },
        "SearchMethod": {
          "type": "string",
          "enum": [
            "full_text",
            "semantic",
            "hybrid",
            "bm25"
          ]
        },
        "SearchOverGroupsData": {
          "type": "object",
          "required": [
            "search_type",
            "query"
          ],
          "properties": {
            "filters": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ChunkFilter"
                }
              ],
              "nullable": true
            },
            "get_total_pages": {
              "type": "boolean",
              "description": "Get total page count for the query accounting for the applied filters. Defaults to false, but can be set to true when the latency penalty is acceptable (typically 50-200ms).",
              "nullable": true
            },
            "group_size": {
              "type": "integer",
              "format": "int32",
              "description": "Group_size is the number of chunks to fetch for each group. The default is 3. If a group has less than group_size chunks, all chunks will be returned. If this is set to a large number, we recommend setting slim_chunks to true to avoid returning the content and chunk_html of the chunks so as to lower the amount of time required for content download and serialization.",
              "nullable": true,
              "minimum": 0
            },
            "highlight_delimiters": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Set highlight_delimiters to a list of strings to use as delimiters for highlighting. If not specified, this defaults to [\"?\", \",\", \".\", \"!\"]. These are the characters that will be used to split the chunk_html into splits for highlighting.",
              "nullable": true
            },
            "highlight_max_length": {
              "type": "integer",
              "format": "int32",
              "description": "Set highlight_max_length to control the maximum number of tokens (typically whitespace separated strings, but sometimes also word stems) which can be present within a single highlight. If not specified, this defaults to 8. This is useful to shorten large splits which may have low scores due to length compared to the query. Set to something very large like 100 to highlight entire splits.",
              "nullable": true,
              "minimum": 0
            },
            "highlight_max_num": {
              "type": "integer",
              "format": "int32",
              "description": "Set highlight_max_num to control the maximum number of highlights per chunk. If not specified, this defaults to 3. It may be less than 3 if no snippets score above the highlight_threshold.",
              "nullable": true,
              "minimum": 0
            },
            "highlight_results": {
              "type": "boolean",
              "description": "Set highlight_results to false for a slight latency improvement (1-10ms). If not specified, this defaults to true. This will add `\u003Cb\u003E\u003Cmark\u003E` tags to the chunk_html of the chunks to highlight matching splits and return the highlights on each scored chunk in the response.",
              "nullable": true
            },
            "highlight_threshold": {
              "type": "number",
              "format": "double",
              "description": "Set highlight_threshold to a lower or higher value to adjust the sensitivity of the highlights applied to the chunk html. If not specified, this defaults to 0.8. The range is 0.0 to 1.0.",
              "nullable": true
            },
            "highlight_window": {
              "type": "integer",
              "format": "int32",
              "description": "Set highlight_window to a number to control the amount of words that are returned around the matched phrases. If not specified, this defaults to 0. This is useful for when you want to show more context around the matched words. When specified, window/2 whitespace separated words are added before and after each highlight in the response's highlights array. If an extended highlight overlaps with another highlight, the overlapping words are only included once.",
              "nullable": true,
              "minimum": 0
            },
            "page": {
              "type": "integer",
              "format": "int64",
              "description": "Page of group results to fetch. Page is 1-indexed.",
              "nullable": true,
              "minimum": 0
            },
            "page_size": {
              "type": "integer",
              "format": "int32",
              "description": "Page size is the number of group results to fetch. The default is 10.",
              "nullable": true,
              "minimum": 0
            },
            "query": {
              "type": "string",
              "description": "Query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set."
            },
            "score_threshold": {
              "type": "number",
              "format": "float",
              "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
              "nullable": true
            },
            "search_type": {
              "$ref": "#/components/schemas/SearchMethod"
            },
            "slim_chunks": {
              "type": "boolean",
              "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.",
              "nullable": true
            }
          }
        },
        "SearchOverGroupsResponseBody": {
          "type": "object",
          "title": "V2",
          "required": [
            "results",
            "total_pages"
          ],
          "properties": {
            "results": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SearchOverGroupsResults"
              }
            },
            "total_pages": {
              "type": "integer",
              "format": "int64"
            }
          }
        },
        "SearchOverGroupsResponseTypes": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/SearchOverGroupsResponseBody"
            },
            {
              "$ref": "#/components/schemas/DeprecatedSearchOverGroupsResponseBody"
            }
          ]
        },
        "SearchOverGroupsResults": {
          "type": "object",
          "title": "V2",
          "required": [
            "group",
            "chunks"
          ],
          "properties": {
            "chunks": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ScoreChunk"
              }
            },
            "file_id": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            },
            "group": {
              "$ref": "#/components/schemas/ChunkGroup"
            }
          }
        },
        "SearchQueryEvent": {
          "type": "object",
          "required": [
            "id",
            "search_type",
            "query",
            "request_params",
            "latency",
            "top_score",
            "results",
            "dataset_id",
            "created_at"
          ],
          "properties": {
            "created_at": {
              "type": "string"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "latency": {
              "type": "number",
              "format": "float"
            },
            "query": {
              "type": "string"
            },
            "request_params": {
              "type": "string"
            },
            "results": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SearchResultType"
              }
            },
            "search_type": {
              "type": "string"
            },
            "top_score": {
              "type": "number",
              "format": "float"
            }
          }
        },
        "SearchQueryResponse": {
          "type": "object",
          "required": [
            "queries"
          ],
          "properties": {
            "queries": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/SearchQueryEvent"
              }
            }
          }
        },
        "SearchRPSGraph": {
          "type": "object",
          "required": [
            "time_stamp",
            "average_rps"
          ],
          "properties": {
            "average_rps": {
              "type": "number",
              "format": "double"
            },
            "time_stamp": {
              "type": "string"
            }
          }
        },
        "SearchResponseBody": {
          "type": "object",
          "title": "V2",
          "required": [
            "chunks",
            "total_pages"
          ],
          "properties": {
            "chunks": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ScoreChunk"
              }
            },
            "total_pages": {
              "type": "integer",
              "format": "int64"
            }
          }
        },
        "SearchResponseTypes": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/SearchResponseBody"
            },
            {
              "$ref": "#/components/schemas/SearchChunkQueryResponseBody"
            }
          ]
        },
        "SearchResultType": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/ScoreChunkDTO"
            },
            {
              "$ref": "#/components/schemas/GroupScoreChunk"
            }
          ]
        },
        "SearchType": {
          "type": "string",
          "enum": [
            "search",
            "autocomplete",
            "search_over_groups",
            "search_within_groups"
          ]
        },
        "SearchTypeCount": {
          "type": "object",
          "required": [
            "search_type",
            "search_method",
            "search_count"
          ],
          "properties": {
            "search_count": {
              "type": "integer",
              "format": "int64"
            },
            "search_method": {
              "type": "string"
            },
            "search_type": {
              "type": "string"
            }
          },
          "example": {
            "search_count": 8,
            "search_type": "search"
          }
        },
        "SearchWithinGroupData": {
          "type": "object",
          "required": [
            "query",
            "search_type"
          ],
          "properties": {
            "filters": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ChunkFilter"
                }
              ],
              "nullable": true
            },
            "get_total_pages": {
              "type": "boolean",
              "description": "Get total page count for the query accounting for the applied filters. Defaults to false, but can be set to true when the latency penalty is acceptable (typically 50-200ms).",
              "nullable": true
            },
            "group_id": {
              "type": "string",
              "format": "uuid",
              "description": "Group specifies the group to search within. Results will only consist of chunks which are bookmarks within the specified group.",
              "nullable": true
            },
            "group_tracking_id": {
              "type": "string",
              "description": "Group_tracking_id specifies the group to search within by tracking id. Results will only consist of chunks which are bookmarks within the specified group. If both group_id and group_tracking_id are provided, group_id will be used.",
              "nullable": true
            },
            "highlight_delimiters": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Set highlight_delimiters to a list of strings to use as delimiters for highlighting. If not specified, this defaults to [\"?\", \",\", \".\", \"!\"]. These are the characters that will be used to split the chunk_html into splits for highlighting.",
              "nullable": true
            },
            "highlight_max_length": {
              "type": "integer",
              "format": "int32",
              "description": "Set highlight_max_length to control the maximum number of tokens (typically whitespace separated strings, but sometimes also word stems) which can be present within a single highlight. If not specified, this defaults to 8. This is useful to shorten large splits which may have low scores due to length compared to the query. Set to something very large like 100 to highlight entire splits.",
              "nullable": true,
              "minimum": 0
            },
            "highlight_max_num": {
              "type": "integer",
              "format": "int32",
              "description": "Set highlight_max_num to control the maximum number of highlights per chunk. If not specified, this defaults to 3. It may be less than 3 if no snippets score above the highlight_threshold.",
              "nullable": true,
              "minimum": 0
            },
            "highlight_results": {
              "type": "boolean",
              "description": "Set highlight_results to false for a slight latency improvement (1-10ms). If not specified, this defaults to true. This will add `\u003Cb\u003E\u003Cmark\u003E` tags to the chunk_html of the chunks to highlight matching splits and return the highlights on each scored chunk in the response.",
              "nullable": true
            },
            "highlight_threshold": {
              "type": "number",
              "format": "double",
              "description": "Set highlight_threshold to a lower or higher value to adjust the sensitivity of the highlights applied to the chunk html. If not specified, this defaults to 0.8. The range is 0.0 to 1.0.",
              "nullable": true
            },
            "highlight_window": {
              "type": "integer",
              "format": "int32",
              "description": "Set highlight_window to a number to control the amount of words that are returned around the matched phrases. If not specified, this defaults to 0. This is useful for when you want to show more context around the matched words. When specified, window/2 whitespace separated words are added before and after each highlight in the response's highlights array. If an extended highlight overlaps with another highlight, the overlapping words are only included once.",
              "nullable": true,
              "minimum": 0
            },
            "location_bias": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/GeoInfoWithBias"
                }
              ],
              "nullable": true
            },
            "page": {
              "type": "integer",
              "format": "int64",
              "description": "The page of chunks to fetch. Page is 1-indexed.",
              "nullable": true,
              "minimum": 0
            },
            "page_size": {
              "type": "integer",
              "format": "int64",
              "description": "The page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.",
              "nullable": true,
              "minimum": 0
            },
            "query": {
              "type": "string",
              "description": "The query is the search query. This can be any string. The query will be used to create an embedding vector and/or SPLADE vector which will be used to find the result set."
            },
            "recency_bias": {
              "type": "number",
              "format": "float",
              "description": "Recency Bias lets you determine how much of an effect the recency of chunks will have on the search results. If not specified, this defaults to 0.0.",
              "nullable": true
            },
            "score_threshold": {
              "type": "number",
              "format": "float",
              "description": "Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.",
              "nullable": true
            },
            "search_type": {
              "$ref": "#/components/schemas/SearchMethod"
            },
            "slim_chunks": {
              "type": "boolean",
              "description": "Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.",
              "nullable": true
            },
            "tag_weights": {
              "type": "object",
              "description": "Tag weights is a JSON object which can be used to boost the ranking of chunks with certain tags. This is useful for when you want to be able to bias towards chunks with a certain tag on the fly. The keys are the tag names and the values are the weights.",
              "additionalProperties": {
                "type": "number",
                "format": "float"
              },
              "nullable": true
            },
            "use_reranker": {
              "type": "boolean",
              "description": "If true, chunks will be reranked using scores from a cross encoder model. \"hybrid\" search will always use the reranker regardless of this setting.",
              "nullable": true
            },
            "use_weights": {
              "type": "boolean",
              "description": "Set use_weights to true to use the weights of the chunks in the result set in order to sort them. If not specified, this defaults to true.",
              "nullable": true
            }
          }
        },
        "SearchWithinGroupResponseBody": {
          "type": "object",
          "title": "V2",
          "required": [
            "chunks",
            "total_pages"
          ],
          "properties": {
            "chunks": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ScoreChunk"
              }
            },
            "total_pages": {
              "type": "integer",
              "format": "int64"
            }
          }
        },
        "SearchWithinGroupResults": {
          "type": "object",
          "title": "V1",
          "required": [
            "bookmarks",
            "group",
            "total_pages"
          ],
          "properties": {
            "bookmarks": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ScoreChunkDTO"
              }
            },
            "group": {
              "$ref": "#/components/schemas/ChunkGroupAndFileId"
            },
            "total_pages": {
              "type": "integer",
              "format": "int64"
            }
          }
        },
        "SetUserApiKeyRequest": {
          "type": "object",
          "required": [
            "name",
            "role"
          ],
          "properties": {
            "dataset_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "The dataset ids which the api key will have access to. If not provided or empty, the api key will have access to all datasets the auth'ed user has access to. If both dataset_ids and organization_ids are provided, the api key will have access to the intersection of the datasets and organizations.",
              "nullable": true
            },
            "name": {
              "type": "string",
              "description": "The name which will be assigned to the new api key."
            },
            "organization_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "The organization ids which the api key will have access to. If not provided or empty, the api key will have access to all organizations the auth'ed user has access to.",
              "nullable": true
            },
            "role": {
              "type": "integer",
              "format": "int32",
              "description": "The role which will be assigned to the new api key. Either 0 (read), 1 (read and write at the level of the currently auth'ed user). The auth'ed user must have a role greater than or equal to the role being assigned which means they must be an admin (1) or owner (2) of the organization to assign write permissions with a role of 1."
            },
            "scopes": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The routes which the api key will have access to. If not provided or empty, the api key will have access to all routes the auth'ed user has access to. Specify the routes as a list of strings. For example, [\"GET /api/dataset\", \"POST /api/dataset\"].",
              "nullable": true
            }
          }
        },
        "SetUserApiKeyResponse": {
          "type": "object",
          "required": [
            "api_key"
          ],
          "properties": {
            "api_key": {
              "type": "string",
              "description": "The api key which was created. This is the value which should be used in the Authorization header."
            }
          }
        },
        "SingleQueuedChunkResponse": {
          "type": "object",
          "required": [
            "chunk_metadata",
            "pos_in_queue"
          ],
          "properties": {
            "chunk_metadata": {
              "$ref": "#/components/schemas/ChunkMetadata"
            },
            "pos_in_queue": {
              "type": "integer",
              "format": "int32",
              "description": "The current position the last access item is in the queue"
            }
          },
          "example": {
            "chunk_metadata": [
              {
                "content": "Some content",
                "link": "https://example.com",
                "metadata": {
                  "key1": "value1",
                  "key2": "value2"
                },
                "tag_set": [
                  "tag1",
                  "tag2"
                ],
                "time_stamp": "2021-01-01 00:00:00.000",
                "tracking_id": "tracking_id",
                "weight": 0.5
              }
            ],
            "pos_in_queue": 1
          }
        },
        "SlimChunkMetadata": {
          "type": "object",
          "required": [
            "id",
            "qdrant_point_id",
            "created_at",
            "updated_at",
            "dataset_id",
            "weight"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "image_urls": {
              "type": "array",
              "items": {
                "type": "string",
                "nullable": true
              },
              "nullable": true
            },
            "link": {
              "type": "string",
              "nullable": true
            },
            "location": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/GeoInfo"
                }
              ],
              "nullable": true
            },
            "metadata": {
              "nullable": true
            },
            "num_value": {
              "type": "number",
              "format": "double",
              "nullable": true
            },
            "qdrant_point_id": {
              "type": "string",
              "format": "uuid"
            },
            "tag_set": {
              "type": "string",
              "nullable": true
            },
            "time_stamp": {
              "type": "string",
              "format": "date-time",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "nullable": true
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            },
            "weight": {
              "type": "number",
              "format": "double"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "link": "https://Mayank.ai",
            "metadata": {
              "key": "value"
            },
            "qdrant_point_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "tag_set": "tag1,tag2",
            "time_stamp": "2021-01-01 00:00:00.000",
            "tracking_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "updated_at": "2021-01-01 00:00:00.000",
            "weight": 0.5
          }
        },
        "SlimChunkMetadataWithArrayTagSet": {
          "type": "object",
          "required": [
            "id",
            "qdrant_point_id",
            "created_at",
            "updated_at",
            "dataset_id",
            "weight"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "image_urls": {
              "type": "array",
              "items": {
                "type": "string",
                "nullable": true
              },
              "nullable": true
            },
            "link": {
              "type": "string",
              "nullable": true
            },
            "location": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/GeoInfo"
                }
              ],
              "nullable": true
            },
            "metadata": {
              "nullable": true
            },
            "num_value": {
              "type": "number",
              "format": "double",
              "nullable": true
            },
            "qdrant_point_id": {
              "type": "string",
              "format": "uuid"
            },
            "tag_set": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "nullable": true
            },
            "time_stamp": {
              "type": "string",
              "format": "date-time",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "nullable": true
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            },
            "weight": {
              "type": "number",
              "format": "double"
            }
          }
        },
        "SlimChunkMetadataWithScore": {
          "type": "object",
          "required": [
            "id",
            "qdrant_point_id",
            "created_at",
            "updated_at",
            "weight",
            "score"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "link": {
              "type": "string",
              "nullable": true
            },
            "metadata": {
              "nullable": true
            },
            "qdrant_point_id": {
              "type": "string",
              "format": "uuid"
            },
            "score": {
              "type": "number",
              "format": "float"
            },
            "tag_set": {
              "type": "string",
              "nullable": true
            },
            "time_stamp": {
              "type": "string",
              "format": "date-time",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "nullable": true
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            },
            "weight": {
              "type": "number",
              "format": "double"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "link": "https://Mayank.ai",
            "metadata": {
              "key": "value"
            },
            "qdrant_point_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "score": 0.9,
            "tag_set": "tag1,tag2",
            "time_stamp": "2021-01-01 00:00:00.000",
            "tracking_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "updated_at": "2021-01-01 00:00:00.000",
            "weight": 0.5
          }
        },
        "SlimUser": {
          "type": "object",
          "required": [
            "id",
            "email",
            "user_orgs",
            "orgs"
          ],
          "properties": {
            "email": {
              "type": "string"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string",
              "nullable": true
            },
            "orgs": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Organization"
              }
            },
            "user_orgs": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/UserOrganization"
              }
            }
          },
          "example": {
            "email": "developers@Mayank.ai",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "name": "Mayank",
            "orgs": [
              {
                "created_at": "2021-01-01 00:00:00.000",
                "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
                "name": "Mayank",
                "registerable": true,
                "updated_at": "2021-01-01 00:00:00.000"
              }
            ],
            "user_orgs": [
              {
                "created_at": "2021-01-01 00:00:00.000",
                "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
                "org_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
                "role": 0,
                "updated_at": "2021-01-01 00:00:00.000",
                "user_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3"
              }
            ]
          }
        },
        "SortBy": {
          "type": "string",
          "enum": [
            "created_at",
            "latency",
            "top_score"
          ]
        },
        "SortOrder": {
          "type": "string",
          "enum": [
            "desc",
            "asc"
          ]
        },
        "StripeInvoice": {
          "type": "object",
          "required": [
            "id",
            "org_id",
            "total",
            "created_at",
            "status",
            "hosted_invoice_url"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "hosted_invoice_url": {
              "type": "string"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "org_id": {
              "type": "string",
              "format": "uuid"
            },
            "status": {
              "type": "string"
            },
            "total": {
              "type": "integer",
              "format": "int32"
            }
          }
        },
        "StripePlan": {
          "type": "object",
          "required": [
            "id",
            "stripe_id",
            "chunk_count",
            "file_storage",
            "user_count",
            "dataset_count",
            "message_count",
            "amount",
            "created_at",
            "updated_at",
            "name"
          ],
          "properties": {
            "amount": {
              "type": "integer",
              "format": "int64"
            },
            "chunk_count": {
              "type": "integer",
              "format": "int32"
            },
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "dataset_count": {
              "type": "integer",
              "format": "int32"
            },
            "file_storage": {
              "type": "integer",
              "format": "int64"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "message_count": {
              "type": "integer",
              "format": "int32"
            },
            "name": {
              "type": "string"
            },
            "stripe_id": {
              "type": "string"
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            },
            "user_count": {
              "type": "integer",
              "format": "int32"
            }
          },
          "example": {
            "amount": 1000,
            "chunk_count": 1000,
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_count": 1,
            "file_storage": 512,
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "message_count": 1000,
            "name": "Free",
            "stripe_id": "plan_123",
            "updated_at": "2021-01-01 00:00:00.000",
            "user_count": 5
          }
        },
        "SuggestedQueriesReqPayload": {
          "type": "object",
          "required": [
            "query"
          ],
          "properties": {
            "query": {
              "type": "string",
              "description": "The query to base the generated suggested queries off of using RAG. A hybrid search for 10 chunks from your dataset using this query will be performed and the context of the chunks will be used to generate the suggested queries."
            }
          }
        },
        "SuggestedQueriesResponse": {
          "type": "object",
          "required": [
            "queries"
          ],
          "properties": {
            "queries": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "Topic": {
          "type": "object",
          "required": [
            "id",
            "name",
            "deleted",
            "created_at",
            "updated_at",
            "dataset_id",
            "owner_id"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid"
            },
            "deleted": {
              "type": "boolean"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "name": {
              "type": "string"
            },
            "owner_id": {
              "type": "string"
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "dataset_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "deleted": false,
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "name": "Mayank",
            "owner_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "updated_at": "2021-01-01 00:00:00.000"
          }
        },
        "UpdateChunkByTrackingIdData": {
          "type": "object",
          "required": [
            "tracking_id"
          ],
          "properties": {
            "chunk_html": {
              "type": "string",
              "description": "HTML content of the chunk you want to update. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content. If no chunk_html is provided, the existing chunk_html will be used.",
              "nullable": true
            },
            "convert_html_to_text": {
              "type": "boolean",
              "description": "Convert HTML to raw text before processing to avoid adding noise to the vector embeddings. By default this is true. If you are using HTML content that you want to be included in the vector embeddings, set this to false.",
              "nullable": true
            },
            "group_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "Group ids are the ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.",
              "nullable": true
            },
            "group_tracking_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Group tracking_ids are the tracking_ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.",
              "nullable": true
            },
            "link": {
              "type": "string",
              "description": "Link of the chunk you want to update. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation. If no link is provided, the existing link will be used.",
              "nullable": true
            },
            "metadata": {
              "description": "The metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. If no metadata is provided, the existing metadata will be used.",
              "nullable": true
            },
            "time_stamp": {
              "type": "string",
              "description": "Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results. If no time_stamp is provided, the existing time_stamp will be used.",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "description": "Tracking_id of the chunk you want to update. This is required to match an existing chunk."
            },
            "weight": {
              "type": "number",
              "format": "double",
              "description": "Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk's dataset dataset. If no weight is provided, the existing weight will be used.",
              "nullable": true
            }
          }
        },
        "UpdateChunkGroupData": {
          "type": "object",
          "properties": {
            "description": {
              "type": "string",
              "description": "Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for. If not provided, the description will not be updated.",
              "nullable": true
            },
            "group_id": {
              "type": "string",
              "format": "uuid",
              "description": "Id of the chunk_group to update.",
              "nullable": true
            },
            "metadata": {
              "description": "Optional metadata to assign to the chunk_group. This is a JSON object that can store any additional information you want to associate with the chunks inside of the chunk_group.",
              "nullable": true
            },
            "name": {
              "type": "string",
              "description": "Name to assign to the chunk_group. Does not need to be unique. If not provided, the name will not be updated.",
              "nullable": true
            },
            "tag_set": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional tags to assign to the chunk_group. This is a list of strings that can be used to categorize the chunks inside the chunk_group.",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "description": "Tracking Id of the chunk_group to update.",
              "nullable": true
            },
            "update_chunks": {
              "type": "boolean",
              "description": "Flag to update the chunks in the group. If true, each chunk in the group will be updated\nby appending the group's tags to the chunk's tags. Default is false.",
              "nullable": true
            }
          }
        },
        "UpdateChunkReqPayload": {
          "type": "object",
          "properties": {
            "boost_phrase": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/BoostPhrase"
                }
              ],
              "nullable": true
            },
            "chunk_html": {
              "type": "string",
              "description": "HTML content of the chunk you want to update. This can also be plaintext. The innerText of the HTML will be used to create the embedding vector. The point of using HTML is for convienience, as some users have applications where users submit HTML content. If no chunk_html is provided, the existing chunk_html will be used.",
              "nullable": true
            },
            "chunk_id": {
              "type": "string",
              "format": "uuid",
              "description": "Id of the chunk you want to update. You can provide either the chunk_id or the tracking_id. If both are provided, the chunk_id will be used.",
              "nullable": true
            },
            "convert_html_to_text": {
              "type": "boolean",
              "description": "Convert HTML to raw text before processing to avoid adding noise to the vector embeddings. By default this is true. If you are using HTML content that you want to be included in the vector embeddings, set this to false.",
              "nullable": true
            },
            "distance_phrase": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/DistancePhrase"
                }
              ],
              "nullable": true
            },
            "group_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "Group ids are the ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.",
              "nullable": true
            },
            "group_tracking_ids": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Group tracking_ids are the tracking_ids of the groups that the chunk should be placed into. This is useful for when you want to update a chunk and add it to a group or multiple groups in one request.",
              "nullable": true
            },
            "image_urls": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Image urls are a list of urls to images that are associated with the chunk. This is useful for when you want to associate images with a chunk. If no image_urls are provided, the existing image_urls will be used.",
              "nullable": true
            },
            "link": {
              "type": "string",
              "description": "Link of the chunk you want to update. This can also be any string. Frequently, this is a link to the source of the chunk. The link value will not affect the embedding creation. If no link is provided, the existing link will be used.",
              "nullable": true
            },
            "location": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/GeoInfo"
                }
              ],
              "nullable": true
            },
            "metadata": {
              "description": "The metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. If no metadata is provided, the existing metadata will be used.",
              "nullable": true
            },
            "num_value": {
              "type": "number",
              "format": "double",
              "description": "Num value is an arbitrary numerical value that can be used to filter chunks. This is useful for when you want to filter chunks by numerical value. If no num_value is provided, the existing num_value will be used.",
              "nullable": true
            },
            "tag_set": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tag set is a list of tags. This can be used to filter chunks by tag. Unlike with metadata filtering, HNSW indices will exist for each tag such that there is not a performance hit for filtering on them. If no tag_set is provided, the existing tag_set will be used.",
              "nullable": true
            },
            "time_stamp": {
              "type": "string",
              "description": "Time_stamp should be an ISO 8601 combined date and time without timezone. It is used for time window filtering and recency-biasing search results. If no time_stamp is provided, the existing time_stamp will be used.",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "description": "Tracking_id of the chunk you want to update. This is required to match an existing chunk.",
              "nullable": true
            },
            "weight": {
              "type": "number",
              "format": "double",
              "description": "Weight is a float which can be used to bias search results. This is useful for when you want to bias search results for a chunk. The magnitude only matters relative to other chunks in the chunk's dataset dataset. If no weight is provided, the existing weight will be used.",
              "nullable": true
            }
          },
          "example": {
            "chunk_html": "\u003Cp\u003ESome HTML content\u003C/p\u003E",
            "chunk_id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
            "group_ids": [
              "d290f1ee-6c54-4b01-90e6-d701748f0851"
            ],
            "link": "https://example.com",
            "metadata": {
              "key1": "value1",
              "key2": "value2"
            },
            "time_stamp": "2021-01-01 00:00:00.000",
            "weight": 0.5
          }
        },
        "UpdateDatasetRequest": {
          "type": "object",
          "properties": {
            "client_configuration": {
              "description": "The new client configuration of the dataset, can be arbitrary JSON. See docs.Mayank.ai for more information. If not provided, the client configuration will not be updated.",
              "nullable": true
            },
            "dataset_id": {
              "type": "string",
              "format": "uuid",
              "description": "The id of the dataset you want to update.",
              "nullable": true
            },
            "dataset_name": {
              "type": "string",
              "description": "The new name of the dataset. Must be unique within the organization. If not provided, the name will not be updated.",
              "nullable": true
            },
            "new_tracking_id": {
              "type": "string",
              "description": "Optional new tracking ID for the dataset. Can be used to track the dataset in external systems. Must be unique within the organization. If not provided, the tracking ID will not be updated.",
              "nullable": true
            },
            "server_configuration": {
              "description": "The new server configuration of the dataset, can be arbitrary JSON. See docs.Mayank.ai for more information. If not provided, the server configuration will not be updated.",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "description": "tracking ID for the dataset. Can be used to track the dataset in external systems.",
              "nullable": true
            }
          },
          "example": {
            "dataset_id": "00000000-0000-0000-0000-000000000000",
            "dataset_name": "My Dataset",
            "server_configuration": {
  
            }
          }
        },
        "UpdateGroupByTrackingIDReqPayload": {
          "type": "object",
          "required": [
            "tracking_id"
          ],
          "properties": {
            "description": {
              "type": "string",
              "description": "Description to assign to the chunk_group. Convenience field for you to avoid having to remember what the group is for. If not provided, the description will not be updated.",
              "nullable": true
            },
            "metadata": {
              "description": "Optional metadata to assign to the chunk_group. This is a JSON object that can store any additional information you want to associate with the chunks inside of the chunk_group.",
              "nullable": true
            },
            "name": {
              "type": "string",
              "description": "Name to assign to the chunk_group. Does not need to be unique. If not provided, the name will not be updated.",
              "nullable": true
            },
            "tag_set": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional tags to assign to the chunk_group. This is a list of strings that can be used to categorize the chunks inside the chunk_group.",
              "nullable": true
            },
            "tracking_id": {
              "type": "string",
              "description": "Tracking Id of the chunk_group to update."
            }
          }
        },
        "UpdateOrganizationData": {
          "type": "object",
          "required": [
            "organization_id"
          ],
          "properties": {
            "name": {
              "type": "string",
              "description": "The new name of the organization. If not provided, the name will not be updated.",
              "nullable": true
            },
            "organization_id": {
              "type": "string",
              "format": "uuid",
              "description": "The id of the organization to update."
            }
          }
        },
        "UpdateTopicReqPayload": {
          "type": "object",
          "required": [
            "topic_id",
            "name"
          ],
          "properties": {
            "name": {
              "type": "string",
              "description": "The new name of the topic. A name is not generated from this field, it is used as-is."
            },
            "topic_id": {
              "type": "string",
              "format": "uuid",
              "description": "The id of the topic to target."
            }
          }
        },
        "UpdateUserOrgRoleData": {
          "type": "object",
          "required": [
            "organization_id",
            "role"
          ],
          "properties": {
            "organization_id": {
              "type": "string",
              "format": "uuid",
              "description": "The id of the organization to update the user for."
            },
            "role": {
              "type": "integer",
              "format": "int32",
              "description": "Either 0 (user), 1 (admin), or 2 (owner). If not provided, the current role will be used. The auth'ed user must have a role greater than or equal to the role being assigned."
            },
            "user_id": {
              "type": "string",
              "format": "uuid",
              "description": "The id of the user to update, if not provided, the auth'ed user will be updated. If provided, the role of the auth'ed user or api key must be an admin (1) or owner (2) of the organization.",
              "nullable": true
            }
          }
        },
        "UploadFileReqPayload": {
          "type": "object",
          "required": [
            "base64_file",
            "file_name"
          ],
          "properties": {
            "base64_file": {
              "type": "string",
              "description": "Base64 encoded file. This is the standard base64url encoding."
            },
            "create_chunks": {
              "type": "boolean",
              "description": "Create chunks is a boolean which determines whether or not to create chunks from the file. If false, you can manually chunk the file and send the chunks to the create_chunk endpoint with the file_id to associate chunks with the file. Meant mostly for advanced users.",
              "nullable": true
            },
            "description": {
              "type": "string",
              "description": "Description is an optional convience field so you do not have to remember what the file contains or is about. It will be included on the group resulting from the file which will hold its chunk.",
              "nullable": true
            },
            "file_name": {
              "type": "string",
              "description": "Name of the file being uploaded, including the extension."
            },
            "group_tracking_id": {
              "type": "string",
              "description": "Group tracking id is an optional field which allows you to specify the tracking id of the group that is created from the file. Chunks created will be created with the tracking id of `group_tracking_id|\u003Cindex of chunk\u003E`",
              "nullable": true
            },
            "link": {
              "type": "string",
              "description": "Link to the file. This can also be any string. This can be used to filter when searching for the file's resulting chunks. The link value will not affect embedding creation.",
              "nullable": true
            },
            "metadata": {
              "description": "Metadata is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata. Will be passed down to the file's chunks.",
              "nullable": true
            },
            "rebalance_chunks": {
              "type": "boolean",
              "description": "Rebalance chunks is an optional field which allows you to specify whether or not to rebalance the chunks created from the file. If not specified, the default true is used. If true, Mayank will evenly distribute remainder splits across chunks such that 66 splits with a `target_splits_per_chunk` of 20 will result in 3 chunks with 22 splits each.",
              "nullable": true
            },
            "split_delimiters": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Split delimiters is an optional field which allows you to specify the delimiters to use when splitting the file before chunking the text. If not specified, the default [.!?\\n] are used to split into sentences. However, you may want to use spaces or other delimiters.",
              "nullable": true
            },
            "tag_set": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Tag set is a comma separated list of tags which will be passed down to the chunks made from the file. Tags are used to filter chunks when searching. HNSW indices are created for each tag such that there is no performance loss when filtering on them.",
              "nullable": true
            },
            "target_splits_per_chunk": {
              "type": "integer",
              "description": "Target splits per chunk. This is an optional field which allows you to specify the number of splits you want per chunk. If not specified, the default 20 is used. However, you may want to use a different number.",
              "nullable": true,
              "minimum": 0
            },
            "time_stamp": {
              "type": "string",
              "description": "Time stamp should be an ISO 8601 combined date and time without timezone. Time_stamp is used for time window filtering and recency-biasing search results. Will be passed down to the file's chunks.",
              "nullable": true
            }
          },
          "example": {
            "base64_file": "base64_encoded_file",
            "create_chunks": true,
            "description": "This is an example file",
            "file_mime_type": "application/pdf",
            "file_name": "example.pdf",
            "link": "https://example.com",
            "metadata": {
              "key1": "value1",
              "key2": "value2"
            },
            "split_delimiters": [
              ",",
              ".",
              "\n"
            ],
            "tag_set": [
              "tag1",
              "tag2"
            ],
            "target_splits_per_chunk": 20,
            "time_stamp": "2021-01-01 00:00:00.000Z"
          }
        },
        "UploadFileResult": {
          "type": "object",
          "required": [
            "file_metadata"
          ],
          "properties": {
            "file_metadata": {
              "$ref": "#/components/schemas/File"
            }
          }
        },
        "UserOrganization": {
          "type": "object",
          "required": [
            "id",
            "user_id",
            "organization_id",
            "role",
            "created_at",
            "updated_at"
          ],
          "properties": {
            "created_at": {
              "type": "string",
              "format": "date-time"
            },
            "id": {
              "type": "string",
              "format": "uuid"
            },
            "organization_id": {
              "type": "string",
              "format": "uuid"
            },
            "role": {
              "type": "integer",
              "format": "int32"
            },
            "updated_at": {
              "type": "string",
              "format": "date-time"
            },
            "user_id": {
              "type": "string",
              "format": "uuid"
            }
          },
          "example": {
            "created_at": "2021-01-01 00:00:00.000",
            "id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "organization_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3",
            "role": 2,
            "updated_at": "2021-01-01 00:00:00.000",
            "user_id": "e3e3e3e3-e3e3-e3e3-e3e3-e3e3e3e3e3e3"
          }
        }
      },
      "securitySchemes": {
        "ApiKey": {
          "type": "apiKey",
          "in": "header",
          "name": "Authorization"
        },
        "X-API-KEY": {
          "type": "apiKey",
          "in": "header",
          "name": "X-API-KEY"
        }
      }
    },
    "tags": [
      {
        "name": "Invitation",
        "description": "Invitation endpoint. Exists to invite users to an organization."
      },
      {
        "name": "Auth",
        "description": "Authentication endpoint. Serves to register and authenticate users."
      },
      {
        "name": "User",
        "description": "User endpoint. Enables you to modify user roles and information."
      },
      {
        "name": "Organization",
        "description": "Organization endpoint. Enables you to modify organization roles and information."
      },
      {
        "name": "Dataset",
        "description": "Dataset endpoint. Datasets belong to organizations and hold configuration information for both client and server. Datasets contain chunks and chunk groups."
      },
      {
        "name": "Chunk",
        "description": "Chunk endpoint. Think of chunks as individual searchable units of information. The majority of your integration will likely be with the Chunk endpoint."
      },
      {
        "name": "Chunk Group",
        "description": "Chunk groups endpoint. Think of a chunk_group as a bookmark folder within the dataset."
      },
      {
        "name": "File",
        "description": "File endpoint. When files are uploaded, they are stored in S3 and broken up into chunks with text extraction from Apache Tika. You can upload files of pretty much any type up to 1GB in size. See chunking algorithm details at `docs.Mayank.ai` for more information on how chunking works. Improved default chunking is on our roadmap."
      },
      {
        "name": "Events",
        "description": "Notifications endpoint. Files are uploaded asynchronously and events are sent to the user when the upload is complete."
      },
      {
        "name": "Topic",
        "description": "Topic chat endpoint. Think of topics as the storage system for gen-ai chat memory. Gen AI messages belong to topics."
      },
      {
        "name": "Message",
        "description": "Message chat endpoint. Messages are units belonging to a topic in the context of a chat with a LLM. There are system, user, and assistant messages."
      },
      {
        "name": "Stripe",
        "description": "Stripe endpoint. Used for the managed SaaS version of this app. Eventually this will become a micro-service. Reach out to the team using contact info found at `docs.Mayank.ai` for more information."
      },
      {
        "name": "Health",
        "description": "Health check endpoint. Used to check if the server is up and running."
      },
      {
        "name": "Metrics",
        "description": "Metrics endpoint. Used to get information for monitoring"
      },
      {
        "name": "Analytics",
        "description": "Analytics endpoint. Used to get information for search and RAG analytics"
      }
    ]
  }